
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Club Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        [v-cloak] { display: none; }

        .site-blur {
            filter: blur(8px);
            pointer-events: none;
            user-select: none;
        }

        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        :root {
            --dl-purple: #4B1F60;
            --dl-light-purple: #7B3FAA;
            --accent-gold: #FFD700;
            --accent-pink: #FF6B9D;
            --charcoal-gray: #333333;
            --soft-light-gray: #F0F4F8;
        }

        .gradient-bg {
            background: linear-gradient(135deg, #17A2B8 0%, #20B2AA 100%);
        }
        
        .card-hover {
            transition: all 0.3s ease;
        }
        
        .card-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgba(91, 42, 134, 0.2), 0 10px 10px -5px rgba(91, 42, 134, 0.1);
        }

        .glass-effect {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--dl-purple) 0%, var(--dl-light-purple) 100%);
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 25px rgba(91, 42, 134, 0.4);
        }

        .btn-coral {
            background: linear-gradient(135deg, var(--accent-pink) 0%, #FF5082 100%);
            transition: all 0.3s ease;
        }

        .btn-coral:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 25px rgba(255, 107, 157, 0.4);
        }
        
        .table-modern {
            border-radius: 12px;
            overflow: hidden;
        }
        
        .nav-tab {
            position: relative;
            transition: all 0.3s ease;
        }
        
        .nav-tab::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 3px;
            background: linear-gradient(135deg, var(--dl-purple) 0%, var(--dl-light-purple) 100%);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .nav-tab.active::after {
            width: 100%;
        }

        .schedule-card {
            background: linear-gradient(135deg, var(--dl-purple) 0%, var(--dl-light-purple) 100%);
            color: white;
        }

        .completed-card {
            background: linear-gradient(135deg, var(--accent-gold) 0%, #FFB300 100%);
            color: var(--charcoal-gray);
        }

        .rating-badge {
            background: linear-gradient(135deg, var(--dl-purple) 0%, var(--dl-light-purple) 100%);
            color: white;
            font-weight: bold;
        }

        .coral-badge {
            background: linear-gradient(135deg, var(--accent-gold) 0%, #FFB300 100%);
            color: white;
            font-weight: bold;
        }

        .yellow-badge {
            background: linear-gradient(135deg, var(--accent-pink) 0%, #FF5082 100%);
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="app" v-cloak class="min-h-screen" style="background-color: var(--soft-light-gray);">
        <!-- Site Password Modal -->
        <div v-if="!siteAuthenticated" class="password-overlay">
            <div class="glass-effect p-8 rounded-2xl shadow-2xl max-w-md w-full m-4 border border-white border-opacity-20">
                <div class="text-center mb-6">
                    <div class="w-16 h-16 bg-gradient-to-r from-green-500 to-teal-600 rounded-full mx-auto mb-4 flex items-center justify-center">
                        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                        </svg>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Pickleball Club</h2>
                    <p class="text-gray-600">Enter the password to access the site</p>
                </div>
                <input
                    v-model="sitePassword"
                    type="password"
                    placeholder="Enter site password"
                    @keyup.enter="attemptSiteLogin"
                    class="w-full p-4 border border-gray-200 rounded-xl mb-6 focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300"
                    autofocus
                >
                <button @click="attemptSiteLogin" class="w-full bg-gradient-to-r from-green-500 to-teal-600 text-white px-6 py-3 rounded-xl font-medium hover:shadow-lg transition-all duration-300">
                    Enter Site
                </button>
            </div>
        </div>

        <!-- Main Content (blurred when not authenticated) -->
        <div :class="{ 'site-blur': !siteAuthenticated }">
        <!-- Header -->
        <div class="text-white shadow-2xl" style="background-color: #4c1f5f;">
            <div class="max-w-7xl mx-auto flex justify-between items-center px-6 py-4">
                <div class="flex items-center justify-center flex-1">
                    <img src="PICK.png" alt="Coventry Pickleball Social" class="h-24 md:h-32">
                </div>
                <div class="flex gap-3">
                    <button v-if="!isAdmin" @click="showAdminLogin = true" class="bg-white bg-opacity-20 px-6 py-2 rounded-xl hover:bg-opacity-30 transition-all duration-300 font-medium backdrop-blur-sm">
                        Admin Login
                    </button>
                    <button v-if="isAdmin" @click="logout" class="btn-coral px-6 py-2 rounded-xl font-medium">
                        Logout
                    </button>
                </div>
            </div>
        </div>

        <!-- Admin Login Modal -->
        <div v-if="showAdminLogin" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 backdrop-blur-sm">
            <div class="glass-effect p-8 rounded-2xl shadow-2xl max-w-md w-full m-4 border border-white border-opacity-20">
                <div class="text-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full mx-auto mb-4 flex items-center justify-center">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                        </svg>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-2">Admin Access</h2>
                    <p class="text-gray-600">Enter your credentials to continue</p>
                </div>
                <input
                    v-model="adminPassword"
                    type="password"
                    placeholder="Enter admin password"
                    @keyup.enter="attemptLogin"
                    class="w-full p-4 border border-gray-200 rounded-xl mb-6 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300"
                >
                <div class="flex gap-3">
                    <button @click="attemptLogin" class="flex-1 btn-primary text-white px-6 py-3 rounded-xl font-medium">
                        Login
                    </button>
                    <button @click="showAdminLogin = false; adminPassword = ''" class="flex-1 bg-gray-200 text-gray-700 px-6 py-3 rounded-xl hover:bg-gray-300 transition-all duration-300 font-medium">
                        Cancel
                    </button>
                </div>
                
            </div>
        </div>

        <!-- Edit Match Modal -->
        <div v-if="editingMatch" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 backdrop-blur-sm">
            <div class="glass-effect p-8 rounded-2xl shadow-2xl max-w-2xl w-full m-4 border border-white border-opacity-20 max-h-[90vh] overflow-y-auto">
                <div class="flex items-center justify-between mb-6">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-800">Edit Match</h2>
                        <p class="text-sm text-gray-600">ID: {{ editingMatch.id }}</p>
                    </div>
                    <button @click="closeEditMatch" class="text-gray-500 hover:text-gray-700">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>

                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
                    <div class="flex items-start">
                        <svg class="w-5 h-5 text-yellow-600 mr-2 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                        </svg>
                        <div>
                            <p class="font-semibold text-yellow-800">Warning</p>
                            <p class="text-sm text-yellow-700">Editing this match will reverse the original rating changes and recalculate based on new scores.</p>
                        </div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div class="grid md:grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="text-sm font-semibold text-gray-700 mb-2">Team A</p>
                            <p class="text-gray-800">{{ getTeamNames(editingMatch.teamA) }}</p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="text-sm font-semibold text-gray-700 mb-2">Team B</p>
                            <p class="text-gray-800">{{ getTeamNames(editingMatch.teamB) }}</p>
                        </div>
                    </div>

                    <div class="grid md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team A Score</label>
                            <input v-model.number="editMatchForm.scoreA" type="number" min="0"
                                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team B Score</label>
                            <input v-model.number="editMatchForm.scoreB" type="number" min="0"
                                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Match Date</label>
                        <input v-model="editMatchForm.date" type="date"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    </div>

                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Notes (optional)</label>
                        <textarea v-model="editMatchForm.notes" rows="2"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"></textarea>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <p class="text-sm text-blue-800">
                            <span class="font-semibold">Current Result:</span>
                            {{ editingMatch.scoreA }} - {{ editingMatch.scoreB }}
                            (Winner: {{ editingMatch.winner === 'Draw' ? 'Draw' : 'Team ' + editingMatch.winner }})
                        </p>
                        <p class="text-sm text-blue-800 mt-1">
                            <span class="font-semibold">New Result:</span>
                            {{ editMatchForm.scoreA }} - {{ editMatchForm.scoreB }}
                            (Winner: {{ editMatchForm.scoreA > editMatchForm.scoreB ? 'Team A' : editMatchForm.scoreB > editMatchForm.scoreA ? 'Team B' : 'Draw' }})
                        </p>
                    </div>
                </div>

                <div class="flex gap-3 mt-6">
                    <button @click="saveMatchEdit" class="flex-1 btn-primary text-white px-6 py-3 rounded-xl font-semibold">
                        Save Changes
                    </button>
                    <button @click="closeEditMatch" class="flex-1 bg-gray-200 text-gray-700 px-6 py-3 rounded-xl hover:bg-gray-300 transition-all duration-300 font-semibold">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Navigation Tabs -->
        <div class="bg-white bg-opacity-80 backdrop-blur-md shadow-lg border-b border-gray-200">
            <div class="max-w-7xl mx-auto">
                <div class="flex overflow-x-auto">
                    <button 
                        v-for="tab in availableTabs" 
                        :key="tab.id"
                        @click="activeTab = tab.id"
                        :class="[
                            'nav-tab px-8 py-4 font-semibold whitespace-nowrap transition-all duration-300 relative',
                            activeTab === tab.id 
                                ? 'text-gray-800 active' 
                                : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'
                        ]"
                    >
                        {{ tab.name }}
                    </button>
                </div>
            </div>
        </div>

        <!-- Content Area -->
        <div class="max-w-7xl mx-auto p-6">
            <!-- League Table -->
            <div v-if="activeTab === 'league'" class="bg-white rounded-2xl shadow-xl p-8 card-hover">
                <div class="flex items-center justify-between mb-6">
                    <div>
                        <h2 class="text-3xl font-bold text-gray-800 mb-2">League Table</h2>
                        <p class="text-gray-600">Player rankings and statistics</p>
                    </div>
                    <div class="flex items-center space-x-2 bg-gradient-to-r from-blue-50 to-purple-50 px-4 py-2 rounded-xl">
                        <svg class="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <span class="text-sm font-medium text-gray-700">{{ players.length }} Active Players</span>
                    </div>
                </div>

                <!-- Date Filter Buttons -->
                <div class="flex flex-wrap gap-2 mb-6 items-center">
                    <button
                        @click="leagueFilter = 'overall'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'overall'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        Overall
                    </button>
                    <button
                        @click="leagueFilter = 'today'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'today'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        Today
                    </button>
                    <button
                        @click="leagueFilter = 'thisWeek'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'thisWeek'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        This Week
                    </button>
                    <button
                        @click="leagueFilter = 'lastWeek'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'lastWeek'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        Last Week
                    </button>
                    <button
                        @click="leagueFilter = 'thisMonth'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'thisMonth'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        This Month
                    </button>
                    <button
                        @click="leagueFilter = 'lastMonth'"
                        :class="[
                            'px-4 py-2 rounded-xl font-semibold transition-all duration-300',
                            leagueFilter === 'lastMonth'
                                ? 'btn-primary text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        ]"
                    >
                        Last Month
                    </button>

                    <!-- Date Picker -->
                    <div class="flex items-center gap-2 ml-4">
                        <span class="text-sm font-medium text-gray-600">or pick a date:</span>
                        <input
                            v-model="selectedDate"
                            @change="leagueFilter = 'customDate'"
                            type="date"
                            class="px-3 py-2 border rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                        >
                    </div>
                </div>

                <!-- Tournament Table Viewer -->
                <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-800 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"></path>
                        </svg>
                        View Tournament Table
                    </h3>
                    <div class="flex items-center gap-3">
                        <input
                            v-model="viewTournamentId"
                            type="text"
                            placeholder="Enter Tournament ID (e.g., T1234567890)"
                            class="flex-1 px-4 py-2 border-2 border-purple-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                        >
                        <button
                            @click="showTournamentTable = !showTournamentTable"
                            :disabled="!viewTournamentId"
                            class="bg-gradient-to-r from-purple-500 to-pink-600 text-white px-6 py-2 rounded-xl font-semibold hover:shadow-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            {{ showTournamentTable ? 'Hide' : 'View' }} Table
                        </button>
                    </div>
                    <p class="text-xs text-gray-600 mt-2">Enter a tournament ID to view the frozen leaderboard for that specific tournament</p>
                </div>

                <!-- Tournament Table Display -->
                <div v-if="showTournamentTable && viewTournamentId" class="mb-6">
                    <template v-if="getTournamentLeaderboard(viewTournamentId)">
                        <div class="bg-white border-2 border-purple-300 rounded-xl p-6">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex items-center justify-between">
                                <span>Tournament Leaderboard</span>
                                <span :class="[
                                    'px-3 py-1 rounded-full text-xs font-semibold',
                                    getTournamentLeaderboard(viewTournamentId).status === 'completed'
                                        ? 'bg-green-100 text-green-800'
                                        : 'bg-yellow-100 text-yellow-800'
                                ]">
                                    {{ getTournamentLeaderboard(viewTournamentId).status === 'completed' ? 'Completed' : 'Active' }}
                                </span>
                            </h3>
                            <div class="grid grid-cols-3 gap-4 mb-6">
                                <div class="bg-gray-50 rounded-lg p-3">
                                    <p class="text-xs text-gray-600">Date</p>
                                    <p class="text-sm font-semibold text-gray-800">{{ formatDate(getTournamentLeaderboard(viewTournamentId).date) }}</p>
                                </div>
                                <div class="bg-gray-50 rounded-lg p-3">
                                    <p class="text-xs text-gray-600">Tournament ID</p>
                                    <p class="text-sm font-semibold text-gray-800">{{ getTournamentLeaderboard(viewTournamentId).tournamentId }}</p>
                                </div>
                                <div class="bg-gray-50 rounded-lg p-3">
                                    <p class="text-xs text-gray-600">Notes</p>
                                    <p class="text-sm font-semibold text-gray-800">{{ getTournamentLeaderboard(viewTournamentId).notes || 'No notes' }}</p>
                                </div>
                            </div>

                            <!-- Live/Final Standings Table -->
                            <div class="overflow-x-auto">
                                <!-- Status Banner for Active Tournaments -->
                                <div v-if="getTournamentLeaderboard(viewTournamentId).status === 'active'" class="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-300 rounded-lg p-4 mb-4">
                                    <div class="flex items-center justify-center gap-2">
                                        <svg class="w-5 h-5 text-blue-600 animate-pulse" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                        </svg>
                                        <p class="text-blue-800 font-semibold">LIVE STANDINGS - Updates as matches are recorded</p>
                                    </div>
                                </div>

                                <table class="w-full">
                                    <thead class="bg-gradient-to-r from-purple-100 to-pink-100">
                                        <tr>
                                            <th class="text-left p-4 font-semibold text-gray-700">Rank</th>
                                            <th @click="sortBy('name')" class="text-left p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Player
                                                <span v-if="sortColumn === 'name'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('games')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Games
                                                <span v-if="sortColumn === 'games'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('wins')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Wins
                                                <span v-if="sortColumn === 'wins'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('losses')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Losses
                                                <span v-if="sortColumn === 'losses'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('pointsFor')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Points For
                                                <span v-if="sortColumn === 'pointsFor'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('pointsAgainst')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Points Against
                                                <span v-if="sortColumn === 'pointsAgainst'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                            <th @click="sortBy('pointDiff')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-purple-200 transition-colors">
                                                Diff
                                                <span v-if="sortColumn === 'pointDiff'">{{ sortDirection === 'asc' ? '▲' : '▼' }}</span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="(player, index) in getLiveTournamentStandings(viewTournamentId)" :key="player.id" class="border-b border-gray-100 hover:bg-purple-50 transition-all">
                                            <td class="p-4">
                                                <div class="flex items-center">
                                                    <div v-if="index < 3" class="w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm mr-2" :class="[
                                                        index === 0 ? 'coral-badge' : '',
                                                        index === 1 ? 'yellow-badge' : '',
                                                        index === 2 ? 'rating-badge' : ''
                                                    ]">
                                                        {{ index + 1 }}
                                                    </div>
                                                    <span v-else class="font-medium text-gray-700">{{ index + 1 }}</span>
                                                </div>
                                            </td>
                                            <td class="p-4">
                                                <div class="font-semibold text-gray-800">{{ player.name }}</div>
                                            </td>
                                            <td class="text-center p-4 font-medium text-gray-700">{{ player.gamesPlayed }}</td>
                                            <td class="text-center p-4">
                                                <span class="bg-green-100 text-green-800 px-2 py-1 rounded-full text-sm font-medium">
                                                    {{ player.wins }}
                                                </span>
                                            </td>
                                            <td class="text-center p-4">
                                                <span class="bg-red-100 text-red-800 px-2 py-1 rounded-full text-sm font-medium">
                                                    {{ player.losses }}
                                                </span>
                                            </td>
                                            <td class="text-center p-4 font-medium text-gray-700">{{ player.pointsScored }}</td>
                                            <td class="text-center p-4 font-medium text-gray-700">{{ player.pointsConceded }}</td>
                                            <td class="text-center p-4">
                                                <span :class="[
                                                    'px-2 py-1 rounded-full text-sm font-medium',
                                                    (player.pointsScored - player.pointsConceded) > 0 ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-700'
                                                ]">
                                                    {{ player.pointsScored - player.pointsConceded >= 0 ? '+' : '' }}{{ player.pointsScored - player.pointsConceded }}
                                                </span>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </template>
                    <template v-else>
                        <div class="bg-red-50 border border-red-200 rounded-xl p-6 text-center">
                            <p class="text-red-800 font-semibold">Tournament ID not found. Please check the ID and try again.</p>
                        </div>
                    </template>
                </div>

                <!-- Main League Table -->
                <h3 v-if="showTournamentTable && viewTournamentId" class="text-xl font-bold text-gray-800 mb-4 mt-8">Overall League Table</h3>
                <div class="overflow-x-auto table-modern">
                    <table class="w-full">
                        <thead class="bg-gradient-to-r from-gray-50 to-gray-100">
                            <tr>
                                <th class="text-left p-4 font-semibold text-gray-700">Rank</th>
                                <th @click="sortLeagueBy('name')" class="text-left p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Player
                                    <span v-if="leagueSortColumn === 'name'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('points')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Points
                                    <span v-if="leagueSortColumn === 'points'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('rating')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Rating
                                    <span v-if="leagueSortColumn === 'rating'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('games')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Games
                                    <span v-if="leagueSortColumn === 'games'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('wins')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Wins
                                    <span v-if="leagueSortColumn === 'wins'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('draws')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Draws
                                    <span v-if="leagueSortColumn === 'draws'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('losses')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Losses
                                    <span v-if="leagueSortColumn === 'losses'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                                <th @click="sortLeagueBy('winpct')" class="text-center p-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors">
                                    Win %
                                    <span v-if="leagueSortColumn === 'winpct'">{{ leagueSortDirection === 'asc' ? '▲' : '▼' }}</span>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="(player, index) in filteredLeaguePlayers" :key="player.id" class="border-b border-gray-100 hover:bg-gradient-to-r hover:from-blue-50 hover:to-purple-50 transition-all duration-300">
                                <td class="p-4">
                                    <div class="flex items-center">
                                        <div v-if="index < 3" class="w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm mr-2" :class="[
                                            index === 0 ? 'coral-badge' : '',
                                            index === 1 ? 'yellow-badge' : '',
                                            index === 2 ? 'rating-badge' : ''
                                        ]">
                                            {{ index + 1 }}
                                        </div>
                                        <span v-else class="font-medium text-gray-700">{{ index + 1 }}</span>
                                    </div>
                                </td>
                                <td class="p-4">
                                    <div class="flex items-center">
                                        <div class="w-10 h-10 rating-badge rounded-full flex items-center justify-center text-white font-bold mr-3">
                                            {{ player.name.charAt(0).toUpperCase() }}
                                        </div>
                                        <div>
                                            <div class="font-semibold text-gray-800">{{ player.name }}</div>
                                            <div class="text-xs text-gray-500">ID: {{ player.id }}</div>
                                        </div>
                                    </div>
                                </td>
                                <td class="text-center p-4">
                                    <span class="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-sm font-bold">
                                        {{ (player.filteredWins * 3) + (player.filteredDraws * 1) }}
                                    </span>
                                </td>
                                <td class="text-center p-4">
                                    <span class="rating-badge px-3 py-1 rounded-full text-sm font-bold">
                                        {{ leagueFilter === 'overall' ? Math.round(player.rating) : Math.round(player.filteredRating) }}
                                    </span>
                                </td>
                                <td class="text-center p-4 font-medium text-gray-700">{{ player.filteredGames }}</td>
                                <td class="text-center p-4">
                                    <span class="bg-green-100 text-green-800 px-2 py-1 rounded-full text-sm font-medium">
                                        {{ player.filteredWins }}
                                    </span>
                                </td>
                                <td class="text-center p-4">
                                    <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm font-medium">
                                        {{ player.filteredDraws }}
                                    </span>
                                </td>
                                <td class="text-center p-4">
                                    <span class="bg-red-100 text-red-800 px-2 py-1 rounded-full text-sm font-medium">
                                        {{ player.filteredLosses }}
                                    </span>
                                </td>
                                <td class="text-center p-4">
                                    <div class="flex items-center justify-center">
                                        <div class="w-16 bg-gray-200 rounded-full h-2 mr-2">
                                            <div class="h-2 rounded-full transition-all duration-500" style="background: linear-gradient(135deg, var(--accent-gold) 0%, var(--dl-purple) 100%);" :style="{width: (player.filteredGames > 0 ? ((player.filteredWins + player.filteredDraws * 0.5) / player.filteredGames * 100) : 0) + '%'}"></div>
                                        </div>
                                        <span class="font-medium text-gray-700">{{ player.filteredGames > 0 ? Math.round((player.filteredWins + player.filteredDraws * 0.5) / player.filteredGames * 100) : 0 }}%</span>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Schedule View -->
            <div v-if="activeTab === 'schedule'" class="bg-white rounded-lg shadow p-6">
                <!-- Today's Tournament Section -->
                <div v-if="groupedTodaysSchedules.length > 0" class="mb-8">
                    <div class="flex items-center mb-6">
                        <div class="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-xl flex items-center justify-center mr-3">
                            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-gray-800">Today's Tournament</h3>
                            <p class="text-gray-600">Record results by round</p>
                        </div>
                    </div>

                    <!-- Tournament Sessions -->
                    <div v-for="session in groupedTodaysSchedules" :key="session.tournamentId" class="space-y-4 mb-6">
                        <!-- Session Header -->
                        <div class="bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-xl p-4">
                            <div class="flex justify-between items-center">
                                <div class="cursor-pointer flex-1" @click="toggleSessionExpand(session.tournamentId)">
                                    <h4 class="text-xl font-bold">{{ formatDate(session.date) }} Tournament{{ session.notes ? ' - ' + session.notes : '' }}</h4>
                                    <p class="text-sm opacity-90">{{ session.rounds.length }} rounds to record</p>
                                    <p class="text-xs opacity-75 mt-1">
                                        <span class="font-semibold">Tournament ID:</span>
                                        <span class="font-mono bg-white bg-opacity-20 px-2 py-0.5 rounded">{{ session.tournamentId }}</span>
                                        <span v-if="!session.tournamentId || session.tournamentId === session.date" class="ml-2 bg-yellow-500 text-yellow-900 px-2 py-0.5 rounded text-xs font-semibold">Old Format</span>
                                    </p>
                                </div>
                                <div class="flex items-center gap-2">
                                    <button @click.stop="viewTournamentId = session.tournamentId; showTournamentTable = true; activeTab = 'league'" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                        View Leaderboard
                                    </button>
                                    <button @click.stop="downloadTournamentCSV(session.tournamentId)" class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                        Download CSV
                                    </button>
                                    <button v-if="isAdmin" @click.stop="openTournamentEditor(session.tournamentId)" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                        Edit
                                    </button>
                                    <button v-if="isAdmin" @click.stop="deleteTournament(session.tournamentId)" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                        Delete
                                    </button>
                                    <button @click="toggleSessionExpand(session.tournamentId)" class="text-2xl">
                                        {{ expandedSessions[session.tournamentId] ? '▼' : '▶' }}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Session Rounds -->
                        <div v-if="expandedSessions[session.tournamentId]" class="space-y-3 ml-4">
                            <div v-for="round in session.rounds" :key="round.roundNumber" class="border-l-4 border-purple-400 pl-4">
                                <!-- Round Header -->
                                <div class="bg-gray-100 rounded-lg p-3 cursor-pointer mb-2" @click="toggleRoundExpand(session.tournamentId + '-' + round.roundNumber)">
                                    <div class="flex justify-between items-center">
                                        <div class="flex items-center gap-3">
                                            <span class="bg-purple-600 text-white px-3 py-1 rounded-full text-sm font-bold">
                                                Round {{ round.roundNumber }}
                                            </span>
                                            <span class="text-sm text-gray-600">{{ round.matches.length}} matches</span>
                                        </div>
                                        <button class="text-purple-600 font-bold">
                                            {{ expandedRounds[session.tournamentId + '-' + round.roundNumber] ? '▼' : '▶' }}
                                        </button>
                                    </div>
                                </div>

                                <!-- Round Matches -->
                                <div v-if="expandedRounds[session.tournamentId + '-' + round.roundNumber]" class="space-y-2 ml-4">
                                    <div v-for="match in round.matches" :key="match.id" class="bg-white border rounded-lg p-4 shadow-sm">
                                        <div class="flex justify-between items-center mb-2">
                                            <div class="flex items-center gap-3">
                                                <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-semibold">
                                                    Court {{ match.court }}
                                                </span>
                                                <span class="font-medium text-sm">{{ getTeamNames(match.teamA) }} vs {{ getTeamNames(match.teamB) }}</span>
                                            </div>
                                        </div>

                                        <!-- Score Input -->
                                        <div class="flex items-center gap-3">
                                            <input
                                                :value="getRoundScore(match.id, 1, 'A')"
                                                @input="updateRoundScore(match.id, 1, 'A', $event.target.value)"
                                                type="number"
                                                min="0"
                                                placeholder="Score"
                                                class="w-20 p-2 border rounded text-gray-800"
                                            >
                                            <span class="font-bold">-</span>
                                            <input
                                                :value="getRoundScore(match.id, 1, 'B')"
                                                @input="updateRoundScore(match.id, 1, 'B', $event.target.value)"
                                                type="number"
                                                min="0"
                                                placeholder="Score"
                                                class="w-20 p-2 border rounded text-gray-800"
                                            >
                                            <button
                                                v-if="getRoundScore(match.id, 1, 'A') !== '' && getRoundScore(match.id, 1, 'B') !== ''"
                                                @click="saveRoundMatch(match)"
                                                class="btn-primary text-white px-4 py-2 rounded-lg text-sm"
                                            >
                                                ✓ Save
                                            </button>
                                            <span v-if="isRoundSaved(match.id, 1)" class="text-green-600 font-semibold">✓ Saved</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- End Tournament Button -->
                        <div v-if="expandedSessions[session.tournamentId]" class="ml-4 mt-6">
                            <button @click="endTournament(session.tournamentId)" class="w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white py-4 px-6 rounded-xl font-semibold text-lg shadow-lg transition-all">
                                <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                End Tournament
                            </button>
                        </div>
                    </div>

                    <!-- Completed Matches -->
                    <div v-if="completedTodaysMatches.length > 0">
                        <p class="text-sm font-medium text-gray-600 mb-3 flex items-center">
                            <svg class="w-4 h-4 mr-2 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            Completed Today
                        </p>
                        <div class="space-y-3">
                            <div v-for="schedule in completedTodaysMatches" :key="schedule.id" class="completed-card rounded-2xl p-4">
                                <div class="flex justify-between items-center">
                                    <div class="flex items-center space-x-4">
                                        <div class="bg-white bg-opacity-20 px-3 py-1 rounded-full text-sm font-semibold">
                                            Court {{ schedule.court }}
                                        </div>
                                        <div class="font-semibold">
                                            {{ getTeamNames(schedule.teamA) }} <span class="mx-2 opacity-75">vs</span> {{ getTeamNames(schedule.teamB) }}
                                        </div>
                                    </div>
                                    <div class="bg-white bg-opacity-20 px-4 py-2 rounded-xl text-sm font-semibold flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                        </svg>
                                        Recorded
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Upcoming Schedules Section -->
                <div>
                    <h2 class="text-xl font-bold mb-4">Upcoming Schedule</h2>
                    <div v-if="schedules.length === 0" class="text-gray-500">
                        No schedules available yet.
                    </div>
                    <div v-else class="space-y-4">
                        <div v-for="schedule in upcomingSchedules" :key="schedule.id" class="border rounded-lg p-4">
                            <div class="flex justify-between items-start mb-2">
                                <h3 class="font-bold text-lg">{{ formatDate(schedule.date) }}</h3>
                                <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-sm">Court {{ schedule.court }}</span>
                            </div>
                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <p class="font-medium text-gray-600 mb-1">Team A</p>
                                    <p>{{ getTeamNames(schedule.teamA) }}</p>
                                </div>
                                <div>
                                    <p class="font-medium text-gray-600 mb-1">Team B</p>
                                    <p>{{ getTeamNames(schedule.teamB) }}</p>
                                </div>
                            </div>
                            <p v-if="schedule.notes" class="text-gray-600 text-sm mt-2">{{ schedule.notes }}</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Match History -->
            <div v-if="activeTab === 'history'" class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-bold mb-4">Match History</h2>

                <!-- Filter Controls -->
                <div class="mb-4 flex gap-4 items-center">
                    <div class="flex-1">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Filter by Player</label>
                        <select v-model="historyPlayerFilter" class="border rounded-lg px-3 py-2 w-full">
                            <option value="">All Players</option>
                            <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                {{ player.name }}
                            </option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Per Page</label>
                        <select v-model="historyPageSize" class="border rounded-lg px-3 py-2">
                            <option :value="10">10</option>
                            <option :value="20">20</option>
                            <option :value="50">50</option>
                            <option :value="100">100</option>
                        </select>
                    </div>
                </div>

                <div v-if="filteredMatches.length === 0" class="text-gray-500">
                    No matches found.
                </div>
                <div v-else class="space-y-3">
                    <div v-for="match in paginatedMatches" :key="match.id" class="border rounded-lg p-4 hover:shadow-md transition-shadow">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex items-center gap-3 cursor-pointer flex-1" @click="toggleMatchExpand(match.id)">
                                <span class="text-sm text-gray-600">{{ formatDate(match.date) }}</span>
                                <span class="bg-purple-100 text-purple-800 px-2 py-1 rounded text-sm">{{ match.format }}</span>
                                <span v-if="match.rounds && Object.keys(match.rounds).length > 1" class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs">
                                    {{ Object.keys(match.rounds).length }} Rounds
                                </span>
                            </div>
                            <div class="flex items-center gap-2">
                                <button v-if="isAdmin" @click="openEditMatch(match)" class="bg-blue-500 text-white px-3 py-1 rounded-lg text-xs hover:bg-blue-600 transition-all">
                                    Edit
                                </button>
                                <button v-if="isAdmin" @click="deleteMatch(match)" class="bg-red-500 text-white px-3 py-1 rounded-lg text-xs hover:bg-red-600 transition-all">
                                    Delete
                                </button>
                                <button class="text-gray-500 hover:text-gray-700" @click="toggleMatchExpand(match.id)">
                                    {{ expandedMatches[match.id] ? '▼' : '▶' }}
                                </button>
                            </div>
                        </div>
                        <div class="grid md:grid-cols-3 gap-4 items-center">
                            <div>
                                <p class="text-sm text-gray-600">Team A</p>
                                <p class="font-medium">{{ getTeamNames(match.teamA) }}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-2xl font-bold">
                                    <span :class="match.winner === 'A' ? 'text-green-600' : ''">{{ match.scoreA }}</span>
                                    -
                                    <span :class="match.winner === 'B' ? 'text-green-600' : ''">{{ match.scoreB }}</span>
                                </p>
                            </div>
                            <div class="text-right">
                                <p class="text-sm text-gray-600">Team B</p>
                                <p class="font-medium">{{ getTeamNames(match.teamB) }}</p>
                            </div>
                        </div>

                        <!-- Round Breakdown -->
                        <div v-if="expandedMatches[match.id] && match.rounds && Object.keys(match.rounds).length > 0" class="mt-4 pt-4 border-t">
                            <h4 class="font-semibold text-sm text-gray-700 mb-2">Round Breakdown:</h4>
                            <div class="space-y-1">
                                <div v-for="(roundData, roundNum) in match.rounds" :key="roundNum" class="flex justify-between items-center bg-gray-50 px-3 py-2 rounded">
                                    <span class="text-sm font-medium text-gray-600">Round {{ roundNum }}:</span>
                                    <span class="text-sm font-bold">
                                        <span :class="roundData.A > roundData.B ? 'text-green-600' : 'text-gray-700'">{{ roundData.A }}</span>
                                        -
                                        <span :class="roundData.B > roundData.A ? 'text-green-600' : 'text-gray-700'">{{ roundData.B }}</span>
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div v-if="match.processed" class="mt-2">
                            <span class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Ratings Updated</span>
                        </div>
                        <div v-if="match.notes" class="mt-2">
                            <span class="text-xs text-gray-600">Note: {{ match.notes }}</span>
                        </div>
                    </div>

                    <!-- Pagination Controls -->
                    <div class="mt-6 flex items-center justify-between border-t pt-4">
                        <div class="text-sm text-gray-600">
                            Showing {{ historyStartIndex + 1 }}-{{ Math.min(historyEndIndex, filteredMatches.length) }} of {{ filteredMatches.length }} matches
                        </div>
                        <div class="flex gap-2">
                            <button
                                @click="historyCurrentPage--"
                                :disabled="historyCurrentPage === 1"
                                :class="historyCurrentPage === 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-purple-700'"
                                class="bg-purple-600 text-white px-4 py-2 rounded-lg transition-all">
                                Previous
                            </button>
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-gray-600">Page {{ historyCurrentPage }} of {{ historyTotalPages }}</span>
                            </div>
                            <button
                                @click="historyCurrentPage++"
                                :disabled="historyCurrentPage === historyTotalPages"
                                :class="historyCurrentPage === historyTotalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-purple-700'"
                                class="bg-purple-600 text-white px-4 py-2 rounded-lg transition-all">
                                Next
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Admin: Players Management -->
            <div v-if="activeTab === 'players' && isAdmin" class="bg-white rounded-lg shadow p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">Manage Players</h2>
                    <button @click="showAddPlayer = true" class="btn-primary text-white px-6 py-3 rounded-xl font-semibold shadow-lg">
                        <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                        Add Player
                    </button>
                </div>

                <!-- Add Player Form -->
                <div v-if="showAddPlayer" class="bg-gray-50 p-4 rounded-lg mb-4">
                    <h3 class="font-bold mb-2">Add New Player</h3>
                    <div class="grid md:grid-cols-2 gap-4">
                        <input v-model="newPlayer.name" placeholder="Player Name" class="p-2 border rounded">
                        <input v-model.number="newPlayer.rating" placeholder="Rating (default 200)" class="p-2 border rounded">
                    </div>
                    <div class="flex gap-2 mt-4">
                        <button @click="addPlayer" class="btn-primary text-white px-6 py-3 rounded-xl font-semibold">
                            Save Player
                        </button>
                        <button @click="cancelAddPlayer" class="bg-gray-200 text-gray-700 px-6 py-3 rounded-xl hover:bg-gray-300 font-semibold transition-all duration-300">
                            Cancel
                        </button>
                    </div>
                </div>

                <!-- Players List -->
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr class="border-b">
                                <th class="text-left p-2">ID</th>
                                <th class="text-left p-2">Name</th>
                                <th class="text-center p-2">Rating</th>
                                <th class="text-center p-2">Games</th>
                                <th class="text-center p-2">W-L</th>
                                <th class="text-center p-2">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="player in alphabeticalPlayers" :key="player.id" class="border-b hover:bg-gray-50">
                                <td class="p-2 font-mono text-sm">{{ player.id }}</td>
                                <td class="p-2">{{ player.name }}</td>
                                <td class="text-center p-2">{{ Math.round(player.rating) }}</td>
                                <td class="text-center p-2">{{ player.gamesPlayed }}</td>
                                <td class="text-center p-2">{{ player.wins }}-{{ player.losses }}</td>
                                <td class="text-center p-2">
                                    <button @click="editPlayer(player)" class="text-blue-600 hover:underline mr-2">Edit</button>
                                    <button @click="deletePlayer(player.id)" class="text-red-600 hover:underline">Delete</button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Admin: Generate Schedule -->
            <div v-if="activeTab === 'scheduler' && isAdmin" class="bg-white rounded-lg shadow p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold">Generate Schedule</h2>
                    <div class="flex gap-2">
                        <button @click="showManualMatch = true" class="btn-coral text-white px-6 py-3 rounded-xl font-semibold shadow-lg">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                            </svg>
                            Create Match
                        </button>
                        <button @click="$refs.csvUpload.click()" class="bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-3 rounded-xl font-semibold shadow-lg transition-all">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                            </svg>
                            Upload CSV
                        </button>
                        <button @click="downloadCSVTemplate" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-xl font-semibold shadow-lg transition-all inline-flex items-center">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                            </svg>
                            Template
                        </button>
                        <input type="file" ref="csvUpload" accept=".csv" @change="uploadTournamentCSV" style="display: none">
                    </div>
                </div>

                <!-- Manual Match Creation Form -->
                <div v-if="showManualMatch" class="bg-gray-50 border-2 border-gray-200 rounded-xl p-6 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-bold">Create Manual Match</h3>
                        <button @click="cancelManualMatch" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="space-y-4">
                        <!-- Match Format -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Match Format</label>
                            <select v-model="manualMatch.format" @change="resetManualMatchPlayers" class="w-full p-2 border rounded">
                                <option value="singles">Singles (1v1)</option>
                                <option value="doubles">Doubles (2v2)</option>
                                <option value="2v1">2v1</option>
                            </select>
                        </div>

                        <!-- Date -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Date</label>
                            <input v-model="manualMatch.date" type="date" class="w-full p-2 border rounded">
                        </div>

                        <!-- Court -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Court Number</label>
                            <input v-model.number="manualMatch.court" type="number" min="1" class="w-full p-2 border rounded">
                        </div>

                        <!-- Number of Games -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Games per Match</label>
                            <input v-model.number="manualMatch.rounds" type="number" min="1" max="20" class="w-full p-2 border rounded" placeholder="e.g., 3">
                            <p class="text-xs text-gray-500 mt-1">Number of games this matchup plays (e.g., best of 3)</p>
                        </div>

                        <!-- Player Selection -->
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Team A</label>
                                <select
                                    v-if="manualMatch.format === 'singles' || (manualMatch.format === '2v1' && manualMatch.teamA.length === 1)"
                                    v-model="manualMatch.teamA[0]"
                                    class="w-full p-2 border rounded mb-2"
                                >
                                    <option value="">Select Player</option>
                                    <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                        {{ player.name }} ({{ Math.round(player.rating) }})
                                    </option>
                                </select>
                                <div v-else class="space-y-2">
                                    <select v-model="manualMatch.teamA[0]" class="w-full p-2 border rounded">
                                        <option value="">Select Player 1</option>
                                        <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                            {{ player.name }} ({{ Math.round(player.rating) }})
                                        </option>
                                    </select>
                                    <select v-model="manualMatch.teamA[1]" class="w-full p-2 border rounded">
                                        <option value="">Select Player 2</option>
                                        <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                            {{ player.name }} ({{ Math.round(player.rating) }})
                                        </option>
                                    </select>
                                </div>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Team B</label>
                                <select
                                    v-if="manualMatch.format === 'singles' || (manualMatch.format === '2v1' && manualMatch.teamB.length === 1)"
                                    v-model="manualMatch.teamB[0]"
                                    class="w-full p-2 border rounded mb-2"
                                >
                                    <option value="">Select Player</option>
                                    <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                        {{ player.name }} ({{ Math.round(player.rating) }})
                                    </option>
                                </select>
                                <div v-else class="space-y-2">
                                    <select v-model="manualMatch.teamB[0]" class="w-full p-2 border rounded">
                                        <option value="">Select Player 1</option>
                                        <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                            {{ player.name }} ({{ Math.round(player.rating) }})
                                        </option>
                                    </select>
                                    <select v-model="manualMatch.teamB[1]" class="w-full p-2 border rounded">
                                        <option value="">Select Player 2</option>
                                        <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                            {{ player.name }} ({{ Math.round(player.rating) }})
                                        </option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Notes -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Notes (Optional)</label>
                            <input v-model="manualMatch.notes" type="text" class="w-full p-2 border rounded" placeholder="e.g., Championship match">
                        </div>

                        <!-- Save Button -->
                        <button @click="saveManualMatch" class="w-full btn-primary text-white py-3 rounded-xl font-semibold">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                            </svg>
                            Save Match to Schedule
                        </button>
                    </div>
                </div>

                <!-- Custom Tournament Builder -->
                <div v-if="showCustomTournament" class="bg-gradient-to-r from-green-50 to-teal-50 border-2 border-green-300 rounded-xl p-6 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="text-lg font-bold text-gray-800">Custom Tournament Builder</h3>
                            <p class="text-sm text-gray-600">Manually select and arrange matches for your tournament</p>
                        </div>
                        <button @click="cancelCustomTournament" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Tournament Settings -->
                    <div class="grid md:grid-cols-3 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Tournament Name</label>
                            <input v-model="customTournament.name" type="text" class="w-full p-2 border rounded" placeholder="e.g., Weekend Cup">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Date</label>
                            <input v-model="customTournament.date" type="date" class="w-full p-2 border rounded">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Format</label>
                            <select v-model="customTournament.format" class="w-full p-2 border rounded">
                                <option value="singles">Singles</option>
                                <option value="doubles">Doubles</option>
                                <option value="2v1">2v1</option>
                            </select>
                        </div>
                    </div>

                    <!-- Rounds Section -->
                    <div class="bg-white rounded-lg p-4 mb-4">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-semibold text-gray-800">Rounds & Matches</h4>
                            <button @click="addCustomRound" class="bg-green-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-green-700 transition-all">
                                + Add Round
                            </button>
                        </div>

                        <!-- Display Rounds -->
                        <div v-if="customTournament.rounds.length === 0" class="text-center text-gray-500 py-8">
                            No rounds added yet. Click "Add Round" to start building your tournament.
                        </div>

                        <div v-for="(round, roundIndex) in customTournament.rounds" :key="roundIndex" class="mb-4 border-2 border-gray-200 rounded-lg p-4">
                            <div class="flex justify-between items-center mb-3">
                                <h5 class="font-semibold text-gray-700">Round {{ roundIndex + 1 }}</h5>
                                <div class="flex gap-2">
                                    <button @click="addCustomMatch(roundIndex)" class="bg-blue-500 text-white px-3 py-1 rounded text-xs hover:bg-blue-600">
                                        + Add Match
                                    </button>
                                    <button @click="deleteCustomRound(roundIndex)" class="bg-red-500 text-white px-3 py-1 rounded text-xs hover:bg-red-600">
                                        Delete Round
                                    </button>
                                </div>
                            </div>

                            <!-- Court Assignment -->
                            <div class="mb-3">
                                <label class="block text-xs font-medium text-gray-600 mb-1">Courts for this round (comma-separated)</label>
                                <input v-model="round.courts" type="text" class="w-full p-2 border rounded text-sm" placeholder="e.g., 1,2,3">
                                <p class="text-xs text-gray-500 mt-1">Matches will be assigned to these courts in order</p>
                            </div>

                            <!-- Matches in this round -->
                            <div v-if="round.matches.length === 0" class="text-center text-gray-400 py-4 text-sm">
                                No matches in this round yet
                            </div>

                            <div v-for="(match, matchIndex) in round.matches" :key="matchIndex" class="bg-gray-50 rounded-lg p-3 mb-2">
                                <div class="flex justify-between items-start mb-2">
                                    <span class="text-xs font-semibold text-gray-600">Match {{ matchIndex + 1 }}</span>
                                    <button @click="deleteCustomMatch(roundIndex, matchIndex)" class="text-red-600 hover:text-red-800 text-xs">
                                        Remove
                                    </button>
                                </div>

                                <div class="grid grid-cols-2 gap-3">
                                    <!-- Team A Selection -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-600 mb-1">Team A</label>
                                        <select
                                            v-if="customTournament.format === 'singles' || (customTournament.format === '2v1' && match.teamA.length === 1)"
                                            v-model="match.teamA[0]"
                                            class="w-full p-2 border rounded text-sm"
                                        >
                                            <option value="">Select Player</option>
                                            <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                {{ player.name }}
                                            </option>
                                        </select>
                                        <div v-else class="space-y-1">
                                            <select v-model="match.teamA[0]" class="w-full p-1 border rounded text-xs">
                                                <option value="">Player 1</option>
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }}
                                                </option>
                                            </select>
                                            <select v-model="match.teamA[1]" class="w-full p-1 border rounded text-xs">
                                                <option value="">Player 2</option>
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }}
                                                </option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- Team B Selection -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-600 mb-1">Team B</label>
                                        <select
                                            v-if="customTournament.format === 'singles' || (customTournament.format === '2v1' && match.teamB.length === 1)"
                                            v-model="match.teamB[0]"
                                            class="w-full p-2 border rounded text-sm"
                                        >
                                            <option value="">Select Player</option>
                                            <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                {{ player.name }}
                                            </option>
                                        </select>
                                        <div v-else class="space-y-1">
                                            <select v-model="match.teamB[0]" class="w-full p-1 border rounded text-xs">
                                                <option value="">Player 1</option>
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }}
                                                </option>
                                            </select>
                                            <select v-model="match.teamB[1]" class="w-full p-1 border rounded text-xs">
                                                <option value="">Player 2</option>
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }}
                                                </option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- Games per match -->
                                <div class="mt-2">
                                    <label class="block text-xs font-medium text-gray-600 mb-1">Games</label>
                                    <input v-model.number="match.rounds" type="number" min="1" max="10" class="w-full p-1 border rounded text-sm" placeholder="e.g., 3">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Save Tournament Button -->
                    <div class="flex gap-3">
                        <button @click="saveCustomTournament" class="flex-1 bg-gradient-to-r from-green-500 to-teal-600 text-white py-3 rounded-xl font-semibold">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                            </svg>
                            Save Custom Tournament to Schedule
                        </button>
                        <button @click="cancelCustomTournament" class="bg-gray-300 text-gray-700 px-6 py-3 rounded-xl font-semibold hover:bg-gray-400">
                            Cancel
                        </button>
                    </div>
                </div>

                <div class="space-y-4">
                    <!-- Match Format -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Match Format</label>
                        <select v-model="scheduleGenerator.format" class="w-full p-2 border rounded">
                            <option value="singles">Singles</option>
                            <option value="doubles">Doubles</option>
                            <option value="2v1">2v1</option>
                        </select>
                    </div>
                    
                    <!-- Date Selection -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Schedule Date</label>
                        <input v-model="scheduleGenerator.date" type="date" class="w-full p-2 border rounded">
                    </div>

                    <!-- Number of Courts -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Number of Courts Available</label>
                        <input v-model.number="scheduleGenerator.courts" type="number" min="1" class="w-full p-2 border rounded">
                    </div>

                    <!-- Number of Games per Match -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Games per Match</label>
                        <input v-model.number="scheduleGenerator.rounds" type="number" min="1" max="20" class="w-full p-2 border rounded" placeholder="e.g., 3">
                        <p class="text-xs text-gray-500 mt-1">Number of games each matchup plays (e.g., best of 3)</p>
                    </div>

                    <!-- Player Selection -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Available Players</label>
                        <div class="border rounded p-3 max-h-48 overflow-y-auto">
                            <label v-for="player in alphabeticalPlayers" :key="player.id" class="flex items-center p-1 hover:bg-gray-50">
                                <input
                                    type="checkbox"
                                    :value="player.id"
                                    v-model="scheduleGenerator.availablePlayers"
                                    class="mr-2"
                                >
                                <span>{{ player.name }} ({{ Math.round(player.rating) }})</span>
                            </label>
                        </div>
                        <p class="text-sm text-gray-600 mt-1">Selected: {{ scheduleGenerator.availablePlayers.length }} players</p>
                    </div>

                    <!-- Notes -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Notes (Optional)</label>
                        <input v-model="scheduleGenerator.notes" type="text" class="w-full p-2 border rounded" placeholder="e.g., Week 5 matches">
                    </div>

                    <!-- Tournament Rounds -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Tournament Rounds (Optional)</label>
                        <input v-model.number="scheduleGenerator.tournamentRounds" type="number" min="1" max="20" class="w-full p-2 border rounded" placeholder="e.g., 10">
                        <p class="text-xs text-gray-500 mt-1">Generate multiple rounds with rotating partners (leave blank for single round)</p>
                    </div>

                    <!-- Keep Same Pairings -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="flex items-center cursor-pointer">
                            <input v-model="scheduleGenerator.keepSamePairings" type="checkbox" class="w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500">
                            <span class="ml-3">
                                <span class="block text-sm font-medium text-gray-800">Keep Same Pairings Throughout Tournament</span>
                                <span class="block text-xs text-gray-600 mt-1">Partners stay together for all rounds, only opponents change</span>
                            </span>
                        </label>
                    </div>

                    <!-- Generate Buttons -->
                    <div class="grid grid-cols-3 gap-4">
                        <button @click="generateSchedule" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-4 rounded-xl font-semibold text-lg shadow-lg hover:shadow-xl transition-all duration-300">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            Single Round
                        </button>
                        <button @click="generateTournament" class="bg-gradient-to-r from-purple-500 to-pink-600 text-white py-4 rounded-xl font-semibold text-lg shadow-lg hover:shadow-xl transition-all duration-300">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"></path>
                            </svg>
                            Multi-Round
                        </button>
                        <button @click="showCustomTournament = true" class="bg-gradient-to-r from-green-500 to-teal-600 text-white py-4 rounded-xl font-semibold text-lg shadow-lg hover:shadow-xl transition-all duration-300">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                            </svg>
                            Custom Tournament
                        </button>
                    </div>

                    <!-- Preview Generated Schedule -->
                    <div v-if="generatedSchedule.length > 0" class="mt-6">
                        <h3 class="font-bold mb-3">Preview & Edit Generated Schedule</h3>
                        <div class="space-y-3 mb-4">
                            <div v-for="(match, index) in generatedSchedule" :key="index" class="border rounded p-4 bg-gray-50">
                                <div class="flex justify-between items-center mb-3">
                                    <div class="flex items-center gap-3">
                                        <span v-if="match.roundNumber" class="bg-purple-600 text-white px-3 py-1 rounded-full text-sm font-bold">
                                            Round {{ match.roundNumber }}
                                        </span>
                                        <span class="font-medium">Court {{ match.court }}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span v-if="match.sitOuts && match.sitOuts.length > 0" class="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                                            Sit: {{ match.sitOuts.map(s => s.name).join(', ') }}
                                        </span>
                                        <span class="text-sm text-gray-600">{{ match.format }}</span>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium mb-1">Team A</label>
                                        <select
                                            v-if="match.format === 'singles' || match.format === '2v1' && match.teamA.length === 1"
                                            v-model="match.teamA[0]"
                                            class="w-full p-2 border rounded"
                                        >
                                            <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                {{ player.name }} ({{ Math.round(player.rating) }})
                                            </option>
                                        </select>
                                        <div v-else class="space-y-2">
                                            <select v-model="match.teamA[0]" class="w-full p-2 border rounded">
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }} ({{ Math.round(player.rating) }})
                                                </option>
                                            </select>
                                            <select v-model="match.teamA[1]" class="w-full p-2 border rounded">
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }} ({{ Math.round(player.rating) }})
                                                </option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium mb-1">Team B</label>
                                        <select
                                            v-if="match.format === 'singles' || match.format === '2v1' && match.teamB.length === 1"
                                            v-model="match.teamB[0]"
                                            class="w-full p-2 border rounded"
                                        >
                                            <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                {{ player.name }} ({{ Math.round(player.rating) }})
                                            </option>
                                        </select>
                                        <div v-else class="space-y-2">
                                            <select v-model="match.teamB[0]" class="w-full p-2 border rounded">
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }} ({{ Math.round(player.rating) }})
                                                </option>
                                            </select>
                                            <select v-model="match.teamB[1]" class="w-full p-2 border rounded">
                                                <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                                    {{ player.name }} ({{ Math.round(player.rating) }})
                                                </option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div v-if="scheduleGenerator.sitOut" class="bg-yellow-50 border border-yellow-200 rounded p-3">
                                <span class="font-medium">Sitting Out:</span> {{ getPlayerName(scheduleGenerator.sitOut) }}
                            </div>
                        </div>
                        <button @click="saveGeneratedSchedule" class="w-full btn-primary text-white py-4 rounded-xl font-semibold text-lg shadow-lg">
                            <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h2m0 0V9a2 2 0 012-2h2a2 2 0 012 2v.93m0 0a2 2 0 01-2 2H9a2 2 0 01-2-2v-.93m0 0a2 2 0 012-2h2a2 2 0 012 2v.93"></path>
                            </svg>
                            Save This Schedule
                        </button>
                    </div>
                </div>
            </div>

            <!-- Admin: Data Management -->
            <div v-if="activeTab === 'data' && isAdmin" class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-bold mb-4">Data Management</h2>
                
                <div class="grid md:grid-cols-2 gap-6">
                    <!-- Export Section -->
                    <div class="border rounded-lg p-4">
                        <h3 class="font-bold mb-3">Export Data</h3>
                        <div class="space-y-3">
                            <button @click="exportJSON" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">
                                📥 Export as JSON (Full Backup)
                            </button>
                            <button @click="exportCSV" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">
                                📊 Export Players as CSV
                            </button>
                            <button @click="printLeague" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700">
                                🖨️ Print League Table
                            </button>
                        </div>
                    </div>

                    <!-- Import Section -->
                    <div class="border rounded-lg p-4">
                        <h3 class="font-bold mb-3">Import Data</h3>
                        <div class="space-y-3">
                            <input type="file" @change="handleFileImport" accept=".json" class="w-full p-2 border rounded">
                            <p class="text-sm text-gray-600">Select a JSON backup file to restore data</p>
                            <button @click="deleteTodaysMatches" class="w-full bg-orange-600 text-white py-2 rounded hover:bg-orange-700">
                                🗑️ Delete Today's Matches
                            </button>
                            <button @click="recalculateAllRatings" class="w-full bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700">
                                🔄 Recalculate All Ratings from 200
                            </button>
                            <button @click="fixNegativeRatings" class="w-full bg-teal-600 text-white py-2 rounded hover:bg-teal-700">
                                🔧 Fix Negative Ratings (Set to 0)
                            </button>
                            <button @click="clearAllData" class="w-full bg-red-600 text-white py-2 rounded hover:bg-red-700">
                                ⚠️ Clear All Data
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tournament Data Migration -->
                <div class="mt-6 border-2 border-orange-200 rounded-xl p-6 bg-gradient-to-r from-orange-50 to-yellow-50">
                    <h3 class="text-xl font-bold mb-4 flex items-center text-orange-800">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                        </svg>
                        Tournament Data Migration
                    </h3>
                    <p class="text-gray-700 mb-4">
                        If you have existing tournament data in memory, use this button to migrate it to the new persistent storage system. 
                        This only needs to be done once after the database update.
                    </p>
                    <div class="flex gap-4">
                        <button @click="migrateTournamentData" class="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 font-semibold">
                            📦 Migrate Tournament Data ({{tournamentsToMigrateCount}} tournaments)
                        </button>
                        <div v-if="migrationStatus" class="flex items-center px-3 py-1 rounded text-sm font-medium" 
                             :class="migrationStatus.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'">
                            {{ migrationStatus.message }}
                        </div>
                    </div>
                </div>

                <!-- Rating Algorithm Documentation -->
                <div class="mt-6 border-2 border-purple-200 rounded-xl p-6 bg-gradient-to-r from-purple-50 to-pink-50">
                    <h3 class="text-xl font-bold mb-4 flex items-center text-purple-800">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        How Player Ratings Work
                    </h3>

                    <div class="bg-white rounded-lg p-5 shadow-sm mb-4">
                        <h4 class="font-bold text-gray-800 mb-3 text-lg">The Simple Version</h4>
                        <div class="space-y-3 text-gray-700">
                            <p class="text-base leading-relaxed">
                                Your rating goes up when you win and down when you lose. <strong>How much it changes depends on who you beat.</strong>
                            </p>
                            <div class="bg-green-50 border-l-4 border-green-500 p-4 rounded">
                                <p class="font-semibold text-green-800 mb-2">Beat someone better than you? 🎉</p>
                                <p class="text-sm text-green-700">You gain lots of points (up to 32 points)</p>
                            </div>
                            <div class="bg-blue-50 border-l-4 border-blue-500 p-4 rounded">
                                <p class="font-semibold text-blue-800 mb-2">Beat someone at your level? 👍</p>
                                <p class="text-sm text-blue-700">You gain a moderate amount (around 8 points)</p>
                            </div>
                            <div class="bg-orange-50 border-l-4 border-orange-500 p-4 rounded">
                                <p class="font-semibold text-orange-800 mb-2">Beat someone weaker than you? 😐</p>
                                <p class="text-sm text-orange-700">You only gain a few points (maybe 3-5 points)</p>
                            </div>
                            <div class="bg-gray-50 border-l-4 border-gray-500 p-4 rounded">
                                <p class="font-semibold text-gray-800 mb-2">Draw with anyone? 🤝</p>
                                <p class="text-sm text-gray-700">Your rating moves slightly toward theirs</p>
                            </div>
                        </div>
                    </div>

                    <div class="grid md:grid-cols-2 gap-4">
                        <!-- Real Examples -->
                        <div class="bg-white rounded-lg p-4 shadow-sm">
                            <h4 class="font-bold text-gray-800 mb-3">Real Examples</h4>
                            <div class="space-y-3">
                                <div class="bg-purple-50 p-3 rounded border border-purple-200">
                                    <p class="font-semibold text-purple-900 mb-1 text-sm">Expected Win</p>
                                    <p class="text-sm text-gray-700">You're rated 250, they're rated 200</p>
                                    <p class="text-sm text-gray-700 mt-1">You win → <span class="text-green-600 font-bold">+11 points</span></p>
                                    <p class="text-sm text-gray-700">You lose → <span class="text-red-600 font-bold">-21 points</span></p>
                                </div>
                                <div class="bg-pink-50 p-3 rounded border border-pink-200">
                                    <p class="font-semibold text-pink-900 mb-1 text-sm">Big Upset!</p>
                                    <p class="text-sm text-gray-700">You're rated 200, they're rated 250</p>
                                    <p class="text-sm text-gray-700 mt-1">You win → <span class="text-green-600 font-bold">+21 points!</span></p>
                                    <p class="text-sm text-gray-700">You lose → <span class="text-red-600 font-bold">-11 points</span></p>
                                </div>
                                <div class="bg-blue-50 p-3 rounded border border-blue-200">
                                    <p class="font-semibold text-blue-900 mb-1 text-sm">Even Match</p>
                                    <p class="text-sm text-gray-700">Both rated 225</p>
                                    <p class="text-sm text-gray-700 mt-1">You win → <span class="text-green-600 font-bold">+16 points</span></p>
                                    <p class="text-sm text-gray-700">Draw → <span class="text-gray-600 font-bold">±0 points</span></p>
                                </div>
                            </div>
                        </div>

                        <!-- Quick Facts -->
                        <div class="bg-white rounded-lg p-4 shadow-sm">
                            <h4 class="font-bold text-gray-800 mb-3">Quick Facts</h4>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div class="flex items-start">
                                    <span class="text-purple-600 mr-2 text-xl">🎯</span>
                                    <p><span class="font-semibold">Everyone starts at 200</span> - Your rating goes up or down from there</p>
                                </div>
                                <div class="flex items-start">
                                    <span class="text-purple-600 mr-2 text-xl">👥</span>
                                    <p><span class="font-semibold">Teams average their ratings</span> - If you're 220 and partner is 180, your team is rated 200</p>
                                </div>
                                <div class="flex items-start">
                                    <span class="text-purple-600 mr-2 text-xl">🤝</span>
                                    <p><span class="font-semibold">Partners share the change</span> - Both teammates get the same rating change</p>
                                </div>
                                <div class="flex items-start">
                                    <span class="text-purple-600 mr-2 text-xl">📊</span>
                                    <p><span class="font-semibold">Maximum change: 32 points</span> - You can't gain or lose more than this per match</p>
                                </div>
                                <div class="flex items-start">
                                    <span class="text-purple-600 mr-2 text-xl">🏆</span>
                                    <p><span class="font-semibold">Beat better players!</span> - That's how you climb the rankings fastest</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Points System Info -->
                    <div class="mt-4 bg-white rounded-lg p-4 shadow-sm border-2 border-green-200">
                        <h4 class="font-bold text-gray-800 mb-3">League Points System (Separate from Ratings)</h4>
                        <p class="text-sm text-gray-600 mb-3">We also track traditional league points for tournaments:</p>
                        <div class="flex gap-6 text-sm flex-wrap">
                            <div class="flex items-center">
                                <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full font-semibold mr-2">Win</span>
                                <span class="text-gray-700 font-semibold">3 points</span>
                            </div>
                            <div class="flex items-center">
                                <span class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full font-semibold mr-2">Draw</span>
                                <span class="text-gray-700 font-semibold">1 point</span>
                            </div>
                            <div class="flex items-center">
                                <span class="bg-red-100 text-red-800 px-3 py-1 rounded-full font-semibold mr-2">Loss</span>
                                <span class="text-gray-700 font-semibold">0 points</span>
                            </div>
                        </div>
                        <p class="text-xs text-gray-600 mt-3 bg-gray-50 p-2 rounded">💡 Your <strong>rating</strong> shows your skill level, while <strong>points</strong> show your tournament performance</p>
                    </div>
                </div>

                <!-- Statistics -->
                <div class="mt-6 grid md:grid-cols-4 gap-4">
                    <div class="bg-gray-50 p-4 rounded-lg text-center">
                        <p class="text-2xl font-bold text-blue-600">{{ players.length }}</p>
                        <p class="text-sm text-gray-600">Total Players</p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg text-center">
                        <p class="text-2xl font-bold text-green-600">{{ matches.length }}</p>
                        <p class="text-sm text-gray-600">Total Matches</p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg text-center">
                        <p class="text-2xl font-bold text-purple-600">{{ schedules.length }}</p>
                        <p class="text-sm text-gray-600">Scheduled Games</p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg text-center">
                        <p class="text-2xl font-bold text-orange-600">{{ unprocessedMatches.length }}</p>
                        <p class="text-sm text-gray-600">Unprocessed</p>
                    </div>
                </div>
            </div>

            <!-- Signup Sheet -->
            <div v-if="activeTab === 'signup'" class="bg-white rounded-lg shadow p-6">
                <!-- Player Selector for Non-Logged Users -->
                <div v-if="!isAdmin && players.length > 0" class="mb-6 p-4 bg-yellow-50 rounded-lg">
                    <h3 class="font-bold text-yellow-800 mb-3">Select Your Name</h3>
                    <select v-model="selectedPlayerId" class="w-full px-3 py-2 border rounded-lg">
                        <option value="">Choose your name...</option>
                        <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                            {{ player.name }}
                        </option>
                    </select>
                    <p class="text-sm text-yellow-700 mt-2">
                        Select your name from the dropdown to mark your availability for game sessions.
                    </p>
                </div>
                <h2 class="text-xl font-bold mb-4">Signup Sheet</h2>
                
                <!-- Admin: Add New Game Session -->
                <div v-if="isAdmin" class="mb-6 p-4 bg-blue-50 rounded-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-blue-800">Manage Game Sessions</h3>
                        <button 
                            @click="showAddSession = true"
                            class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                            + Add New Session
                        </button>
                    </div>
                    
                    <!-- Add Session Modal -->
                    <div v-if="showAddSession" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                        <div class="bg-white p-6 rounded-lg max-w-md w-full mx-4">
                            <h4 class="text-lg font-bold mb-4">Add New Game Session</h4>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-medium mb-1">Date</label>
                                    <input v-model="newGameSession.date" type="date" 
                                           class="w-full px-3 py-2 border rounded-lg">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">Time</label>
                                    <input v-model="newGameSession.time" type="time" 
                                           class="w-full px-3 py-2 border rounded-lg">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">Courts Available</label>
                                    <input v-model.number="newGameSession.courts" type="number" min="1" max="10"
                                           class="w-full px-3 py-2 border rounded-lg">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">Max Players</label>
                                    <input v-model.number="newGameSession.maxPlayers" type="number" min="2" max="50"
                                           class="w-full px-3 py-2 border rounded-lg">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">Notes</label>
                                    <input v-model="newGameSession.notes" type="text" 
                                           placeholder="e.g., Weekday evening session"
                                           class="w-full px-3 py-2 border rounded-lg">
                                </div>
                            </div>
                            <div class="flex gap-2 mt-6">
                                <button @click="addGameSession" 
                                        class="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700">
                                    Add Session
                                </button>
                                <button @click="showAddSession = false" 
                                        class="flex-1 bg-gray-300 text-gray-700 py-2 rounded hover:bg-gray-400">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Game Sessions List -->
                <div v-if="gameSessions.length === 0" class="text-center py-8 text-gray-500">
                    <p>No game sessions available yet.</p>
                    <p v-if="!isAdmin" class="text-sm">Contact admin to add game dates.</p>
                </div>
                
                <div v-else class="space-y-4">
                    <div v-for="session in sortedGameSessions" :key="session.id" 
                         class="border rounded-lg p-4 hover:bg-gray-50">
                        <div class="flex justify-between items-start">
                            <div class="flex-1">
                                <div class="flex items-center gap-4 mb-2">
                                    <h4 class="font-bold text-lg">{{ formatDateDisplay(session.date) }}</h4>
                                    <span class="text-gray-600">{{ session.time }}</span>
                                </div>
                                <div class="text-sm text-gray-600 mb-2">
                                    {{ session.courts }} court(s) • Max {{ session.maxPlayers }} players
                                    <span v-if="session.notes"> • {{ session.notes }}</span>
                                </div>
                                
                                <!-- Signup Summary -->
                                <div class="flex items-center gap-4 text-sm">
                                    <span class="text-green-600">
                                        Available: {{ getAvailablePlayersCount(session.id) }}
                                    </span>
                                    <span class="text-red-600">
                                        Not Available: {{ getUnavailablePlayersCount(session.id) }}
                                    </span>
                                    <span class="text-gray-600">
                                        No Response: {{ getNoResponsePlayersCount(session.id) }}
                                    </span>
                                </div>
                            </div>
                            
                            <!-- Player Action Area -->
                            <div v-if="!isAdmin && session.status === 'active'" class="ml-4">
                                <div class="text-sm font-medium mb-2">Your Status:</div>
                                <div class="flex gap-2">
                                    <button @click="setPlayerAvailability(session.id, true)"
                                            :class="getPlayerAvailability(session.id) === true ? 
                                                   'bg-green-600 text-white' : 'bg-gray-200 text-gray-700'"
                                            class="px-3 py-1 rounded text-sm hover:opacity-80">
                                        Available
                                    </button>
                                    <button @click="setPlayerAvailability(session.id, false)"
                                            :class="getPlayerAvailability(session.id) === false ? 
                                                   'bg-red-600 text-white' : 'bg-gray-200 text-gray-700'"
                                            class="px-3 py-1 rounded text-sm hover:opacity-80">
                                        Not Available
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Admin Controls -->
                            <div v-if="isAdmin" class="ml-4 flex gap-2">
                                <button @click="toggleSessionDetails(session.id)"
                                        class="bg-blue-100 text-blue-700 px-3 py-1 rounded text-sm hover:bg-blue-200">
                                    View Details
                                </button>
                                <button @click="cancelGameSession(session.id)"
                                        v-if="session.status === 'active'"
                                        class="bg-red-100 text-red-700 px-3 py-1 rounded text-sm hover:bg-red-200">
                                    Delete
                                </button>
                            </div>
                        </div>
                        
                        <!-- Detailed Player List (Admin View) -->
                        <div v-if="isAdmin && sessionDetailsExpanded[session.id]" 
                             class="mt-4 pt-4 border-t bg-gray-50 -mx-4 px-4 -mb-4 pb-4">
                            <h5 class="font-medium mb-3">Player Responses:</h5>
                            <div class="grid md:grid-cols-3 gap-4">
                                <!-- Available Players -->
                                <div>
                                    <h6 class="text-sm font-medium text-green-700 mb-2">
                                        Available ({{ getSessionAvailablePlayers(session.id).length }})
                                    </h6>
                                    <ul class="text-sm space-y-1">
                                        <li v-for="player in getSessionAvailablePlayers(session.id)" 
                                            :key="player.id" class="text-green-600">
                                            {{ player.name }}
                                        </li>
                                    </ul>
                                </div>
                                
                                <!-- Not Available Players -->
                                <div>
                                    <h6 class="text-sm font-medium text-red-700 mb-2">
                                        Not Available ({{ getSessionUnavailablePlayers(session.id).length }})
                                    </h6>
                                    <ul class="text-sm space-y-1">
                                        <li v-for="player in getSessionUnavailablePlayers(session.id)" 
                                            :key="player.id" class="text-red-600">
                                            {{ player.name }}
                                        </li>
                                    </ul>
                                </div>
                                
                                <!-- No Response Players -->
                                <div>
                                    <h6 class="text-sm font-medium text-gray-700 mb-2">
                                        No Response ({{ getSessionNoResponsePlayers(session.id).length }})
                                    </h6>
                                    <ul class="text-sm space-y-1">
                                        <li v-for="player in getSessionNoResponsePlayers(session.id)" 
                                            :key="player.id" class="text-gray-600">
                                            {{ player.name }}
                                        </li>
                                    </ul>
                                </div>
                            </div>
                            
                            <!-- Create Tournament Button -->
                            <div class="mt-4 pt-4 border-t">
                                <button @click="createTournamentFromSession(session.id)"
                                        :disabled="getSessionAvailablePlayers(session.id).length < 4"
                                        class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 disabled:bg-gray-300 disabled:cursor-not-allowed">
                                    Create Tournament ({{ getSessionAvailablePlayers(session.id).length }} available)
                                </button>
                                <p class="text-xs text-gray-500 mt-1">
                                    Minimum 4 players required to create a tournament
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>

        <!-- Tournament Edit Modal (At Root Level) -->
        <div v-if="showEditScheduleModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" @click.self="closeEditModal">
            <div class="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
                <div class="sticky top-0 bg-gradient-to-r from-blue-600 to-indigo-600 text-white p-6 rounded-t-xl z-10">
                    <div class="flex justify-between items-center">
                        <h3 class="text-2xl font-bold">Edit Tournament</h3>
                        <button @click="closeEditModal" class="text-white hover:text-gray-200 text-3xl">&times;</button>
                    </div>
                    <p class="text-sm opacity-90 mt-2">Tournament ID: {{ editingTournamentId }}</p>
                </div>

                <div class="p-6 space-y-4">
                    <div v-for="schedule in getTournamentSchedules(editingTournamentId)" :key="schedule.id" class="border rounded-lg p-4 bg-gray-50">
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-semibold mr-2">
                                    Court {{ schedule.court }}
                                </span>
                                <span class="text-sm text-gray-600">{{ schedule.format }}</span>
                            </div>
                            <button @click="deleteSchedule(schedule.id)" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-xs transition-colors">
                                Remove
                            </button>
                        </div>

                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-2">Team A</label>
                                <select v-for="(playerId, idx) in schedule.teamA" :key="'A-'+idx"
                                        v-model="schedule.teamA[idx]"
                                        class="w-full p-2 border rounded mb-2">
                                    <option value="">Select Player</option>
                                    <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                        {{ player.name }}
                                    </option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-2">Team B</label>
                                <select v-for="(playerId, idx) in schedule.teamB" :key="'B-'+idx"
                                        v-model="schedule.teamB[idx]"
                                        class="w-full p-2 border rounded mb-2">
                                    <option value="">Select Player</option>
                                    <option v-for="player in alphabeticalPlayers" :key="player.id" :value="player.id">
                                        {{ player.name }}
                                    </option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sticky bottom-0 bg-gray-50 p-6 rounded-b-xl border-t flex justify-end gap-3 z-10">
                    <button @click="closeEditModal" class="px-6 py-2 bg-gray-300 hover:bg-gray-400 rounded-lg font-semibold transition-colors">
                        Cancel
                    </button>
                    <button @click="saveTournamentChanges" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors">
                        Save Changes
                    </button>
                </div>
            </div>
        </div>
        </div><!-- End blur wrapper -->
    </div>

    <script>
        const { createClient } = supabase;
        
        // Initialize Supabase
        const supabaseUrl = 'https://lbymuskkehekukdhdrim.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxieW11c2trZWhla3VrZGhkcmltIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIyNDg4ODgsImV4cCI6MjA3NzgyNDg4OH0.jqdjt6rNGBaydAfhgwh_lhF0rJ-5Yd-RnQ8_LHWvbO4';
        const sb = createClient(supabaseUrl, supabaseKey);

        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // Site Access
                    siteAuthenticated: false,
                    sitePassword: '',
                    sitePasswordHash: 'pickle2026',

                    // Auth
                    isAdmin: false,
                    showAdminLogin: false,
                    adminPassword: '',
                    adminPasswordHash: 'admin123', // In production, use proper hashing

                    // Navigation
                    activeTab: 'league',
                    leagueFilter: 'overall',
                    selectedDate: null,

                    // Data
                    players: [],
                    matches: [],
                    ratingsHistory: [],
                    schedules: [],
                    tournamentLeaderboards: [], // Stores snapshots of tournament standings
                    migrationStatus: null, // Status of tournament data migration

                    // Signup Sheet Data
                    gameSessions: [], // Admin-created game sessions
                    playerAvailability: [], // Player signup data

                    // Forms
                    showAddPlayer: false,
                    newPlayer: {
                        name: '',
                        rating: 200
                    },
                    newMatch: {
                        format: 'doubles',
                        date: new Date().toISOString().split('T')[0],
                        teamA: [],
                        teamB: [],
                        scoreA: 0,
                        scoreB: 0,
                        notes: '',
                        scheduleId: null
                    },
                    scheduleGenerator: {
                        date: new Date().toISOString().split('T')[0],
                        courts: 2,
                        format: 'doubles',
                        rounds: 3,
                        tournamentRounds: null,
                        availablePlayers: [],
                        notes: '',
                        sitOut: null,
                        keepSamePairings: false
                    },
                    
                    // Signup Sheet Forms
                    showAddSession: false,
                    selectedPlayerId: '', // For non-admin player selection
                    sessionDetailsExpanded: {}, // Track which session details are expanded
                    newGameSession: {
                        date: new Date().toISOString().split('T')[0],
                        time: '18:00',
                        courts: 2,
                        maxPlayers: 8,
                        notes: '',
                        status: 'active'
                    },
                    generatedSchedule: [],
                    showManualMatch: false,
                    manualMatch: {
                        format: 'doubles',
                        date: new Date().toISOString().split('T')[0],
                        court: 1,
                        rounds: 3,
                        teamA: ['', ''],
                        teamB: ['', ''],
                        notes: ''
                    },

                    // Custom Tournament Builder
                    showCustomTournament: false,
                    customTournament: {
                        name: '',
                        date: new Date().toISOString().split('T')[0],
                        format: 'doubles',
                        rounds: [] // Array of { courts: '', matches: [{teamA: [], teamB: [], rounds: 3}] }
                    },
                    // Round recording tracking
                    expandedSchedules: {},
                    roundScores: {}, // { scheduleId: { roundNumber: { A: score, B: score, saved: boolean } } }
                    expandedMatches: {}, // Track expanded matches in history
                    expandedSessions: {}, // Track which date sessions are expanded
                    expandedRounds: {}, // Track which rounds are expanded

                    // Match history pagination
                    historyPlayerFilter: '',
                    historyPageSize: 20,
                    historyCurrentPage: 1,

                    // Edit match
                    editingMatch: null,
                    editMatchForm: {
                        scoreA: 0,
                        scoreB: 0,
                        date: '',
                        notes: ''
                    },

                    // Tournament table viewing
                    viewTournamentId: '', // Input field for tournament ID to view
                    showTournamentTable: false, // Toggle tournament table view

                    // Table sorting (for tournament tables)
                    sortColumn: 'pointDiff', // Default sort by point differential
                    sortDirection: 'desc',

                    // League table sorting
                    leagueSortColumn: 'points', // Default sort by points
                    leagueSortDirection: 'desc',

                    // Tournament editing
                    editingTournamentId: null,
                    editingSchedule: null,
                    showEditScheduleModal: false
                }
            },
            computed: {
                availableTabs() {
                    const publicTabs = [
                        { id: 'league', name: 'League Table' },
                        { id: 'schedule', name: 'Schedule' },
                        { id: 'history', name: 'Match History' },
                        { id: 'signup', name: 'Signup Sheet' }
                    ];
                    
                    const adminTabs = [
                        { id: 'players', name: 'Players' },
                        { id: 'scheduler', name: 'Generate Schedule' },
                        { id: 'data', name: 'Data Management' }
                    ];
                    
                    return this.isAdmin ? [...publicTabs, ...adminTabs] : publicTabs;
                },
                sortedPlayers() {
                    return [...this.players].map(player => ({
                        ...player,
                        gamesPlayed: player.wins + (player.draws || 0) + player.losses
                    })).sort((a, b) => b.rating - a.rating);
                },
                alphabeticalPlayers() {
                    return [...this.players].sort((a, b) => a.name.localeCompare(b.name));
                },
                recentMatches() {
                    return [...this.matches].sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 20);
                },
                tournamentsToMigrateCount() {
                    const tournamentIds = [...new Set(
                        this.schedules
                            .filter(s => s.tournamentId && s.tournamentId.trim())
                            .map(s => s.tournamentId)
                    )];
                    return tournamentIds.length;
                },
                filteredMatches() {
                    let filtered = [...this.matches];

                    // Filter by player if selected
                    if (this.historyPlayerFilter) {
                        filtered = filtered.filter(match =>
                            match.teamA.includes(this.historyPlayerFilter) ||
                            match.teamB.includes(this.historyPlayerFilter)
                        );
                    }

                    // Sort by date (most recent first)
                    return filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
                },
                historyTotalPages() {
                    return Math.max(1, Math.ceil(this.filteredMatches.length / this.historyPageSize));
                },
                historyStartIndex() {
                    return (this.historyCurrentPage - 1) * this.historyPageSize;
                },
                historyEndIndex() {
                    return this.historyCurrentPage * this.historyPageSize;
                },
                paginatedMatches() {
                    return this.filteredMatches.slice(this.historyStartIndex, this.historyEndIndex);
                },
                upcomingSchedules() {
                    const today = new Date().toISOString().split('T')[0];

                    // Get all dates that have tournaments (multiple rounds)
                    const tournamentDates = new Set();
                    this.schedules.forEach(s => {
                        if (s.roundNumber && s.roundNumber > 1) {
                            tournamentDates.add(s.date);
                        }
                    });

                    // Also check for dates with multiple schedules having round numbers
                    const dateRoundCounts = {};
                    this.schedules.forEach(s => {
                        if (s.roundNumber) {
                            if (!dateRoundCounts[s.date]) {
                                dateRoundCounts[s.date] = new Set();
                            }
                            dateRoundCounts[s.date].add(s.roundNumber);
                        }
                    });

                    Object.entries(dateRoundCounts).forEach(([date, rounds]) => {
                        if (rounds.size > 1) {
                            tournamentDates.add(date);
                        }
                    });

                    // Filter out tournament dates and only show upcoming single matches
                    return [...this.schedules]
                        .filter(s => s.date >= today && !tournamentDates.has(s.date))
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                },
                unprocessedMatches() {
                    return this.matches.filter(m => !m.processed);
                },
                todaysScheduledMatches() {
                    const today = new Date().toISOString().split('T')[0];
                    // Only show schedules that don't have a corresponding match recorded
                    return this.schedules.filter(schedule => {
                        if (schedule.date !== today) return false;
                        
                        // Check if there's already a match for this schedule
                        const hasMatch = this.matches.some(match => {
                            const sameDate = match.date === schedule.date;
                            const sameTeams = 
                                (JSON.stringify([...match.teamA].sort()) === JSON.stringify([...schedule.teamA].sort()) &&
                                 JSON.stringify([...match.teamB].sort()) === JSON.stringify([...schedule.teamB].sort())) ||
                                (JSON.stringify([...match.teamA].sort()) === JSON.stringify([...schedule.teamB].sort()) &&
                                 JSON.stringify([...match.teamB].sort()) === JSON.stringify([...schedule.teamA].sort()));
                            return sameDate && sameTeams;
                        });
                        
                        return !hasMatch;
                    });
                },
                completedTodaysMatches() {
                    const today = new Date().toISOString().split('T')[0];
                    // Show schedules that have a corresponding match recorded
                    return this.schedules.filter(schedule => {
                        if (schedule.date !== today) return false;

                        // Check if there's already a match for this schedule
                        const hasMatch = this.matches.some(match => {
                            const sameDate = match.date === schedule.date;
                            const sameTeams =
                                (JSON.stringify([...match.teamA].sort()) === JSON.stringify([...schedule.teamA].sort()) &&
                                 JSON.stringify([...match.teamB].sort()) === JSON.stringify([...schedule.teamB].sort())) ||
                                (JSON.stringify([...match.teamA].sort()) === JSON.stringify([...schedule.teamB].sort()) &&
                                 JSON.stringify([...match.teamB].sort()) === JSON.stringify([...schedule.teamA].sort()));
                            return sameDate && sameTeams;
                        });

                        return hasMatch;
                    });
                },
                groupedTodaysSchedules() {
                    const today = new Date().toISOString().split('T')[0];
                    const todaysSchedules = this.schedules.filter(s => s.date === today);

                    if (todaysSchedules.length === 0) return [];

                    // Group by tournament ID
                    const grouped = {};

                    todaysSchedules.forEach(schedule => {
                        const tournamentKey = schedule.tournamentId || schedule.date;
                        if (!grouped[tournamentKey]) {
                            grouped[tournamentKey] = {
                                tournamentId: tournamentKey,
                                date: schedule.date,
                                notes: schedule.notes,
                                rounds: []
                            };
                        }

                        // Find or create round group
                        const roundNum = schedule.roundNumber || 1;
                        let roundGroup = grouped[tournamentKey].rounds.find(r => r.roundNumber === roundNum);

                        if (!roundGroup) {
                            roundGroup = {
                                roundNumber: roundNum,
                                matches: []
                            };
                            grouped[tournamentKey].rounds.push(roundGroup);
                        }

                        roundGroup.matches.push(schedule);
                    });

                    // Sort rounds
                    Object.values(grouped).forEach(session => {
                        session.rounds.sort((a, b) => a.roundNumber - b.roundNumber);
                    });

                    return Object.values(grouped);
                },

                filteredLeaguePlayers() {
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                    // Get date ranges
                    let startDate, endDate;

                    if (this.leagueFilter === 'overall') {
                        // Map overall stats
                        const overallPlayers = this.sortedPlayers.map(p => ({
                            ...p,
                            filteredGames: p.gamesPlayed,
                            filteredWins: p.wins,
                            filteredDraws: p.draws || 0,
                            filteredLosses: p.losses,
                            filteredRating: p.rating
                        }));

                        // Apply sorting to overall view
                        return [...overallPlayers].sort((a, b) => {
                            let valA, valB;

                            switch(this.leagueSortColumn) {
                                case 'name':
                                    valA = a.name.toLowerCase();
                                    valB = b.name.toLowerCase();
                                    break;
                                case 'points':
                                    valA = (a.filteredWins * 3) + (a.filteredDraws * 1);
                                    valB = (b.filteredWins * 3) + (b.filteredDraws * 1);
                                    break;
                                case 'rating':
                                    valA = a.rating;
                                    valB = b.rating;
                                    break;
                                case 'games':
                                    valA = a.filteredGames;
                                    valB = b.filteredGames;
                                    break;
                                case 'wins':
                                    valA = a.filteredWins;
                                    valB = b.filteredWins;
                                    break;
                                case 'draws':
                                    valA = a.filteredDraws;
                                    valB = b.filteredDraws;
                                    break;
                                case 'losses':
                                    valA = a.filteredLosses;
                                    valB = b.filteredLosses;
                                    break;
                                case 'winpct':
                                    valA = a.filteredGames > 0 ? (a.filteredWins + a.filteredDraws * 0.5) / a.filteredGames : 0;
                                    valB = b.filteredGames > 0 ? (b.filteredWins + b.filteredDraws * 0.5) / b.filteredGames : 0;
                                    break;
                                default:
                                    valA = (a.filteredWins * 3) + (a.filteredDraws * 1);
                                    valB = (b.filteredWins * 3) + (b.filteredDraws * 1);
                                    break;
                            }

                            if (this.leagueSortDirection === 'asc') {
                                return valA > valB ? 1 : valA < valB ? -1 : 0;
                            } else {
                                return valA < valB ? 1 : valA > valB ? -1 : 0;
                            }
                        });
                    } else if (this.leagueFilter === 'today') {
                        startDate = new Date(today);
                        endDate = new Date(today);
                        endDate.setHours(23, 59, 59);
                    } else if (this.leagueFilter === 'customDate' && this.selectedDate) {
                        const customDate = new Date(this.selectedDate);
                        startDate = new Date(customDate);
                        endDate = new Date(customDate);
                        endDate.setHours(23, 59, 59);
                    } else if (this.leagueFilter === 'thisMonth') {
                        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
                    } else if (this.leagueFilter === 'lastMonth') {
                        startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                        endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59);
                    } else if (this.leagueFilter === 'thisWeek') {
                        const dayOfWeek = now.getDay();
                        const monday = new Date(today);
                        monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
                        startDate = monday;
                        endDate = new Date(monday);
                        endDate.setDate(monday.getDate() + 6);
                        endDate.setHours(23, 59, 59);
                    } else if (this.leagueFilter === 'lastWeek') {
                        const dayOfWeek = now.getDay();
                        const lastMonday = new Date(today);
                        lastMonday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1) - 7);
                        startDate = lastMonday;
                        endDate = new Date(lastMonday);
                        endDate.setDate(lastMonday.getDate() + 6);
                        endDate.setHours(23, 59, 59);
                    }

                    // Filter matches by date range
                    const filteredMatches = this.matches.filter(m => {
                        const matchDate = new Date(m.date);
                        return m.processed && matchDate >= startDate && matchDate <= endDate;
                    });

                    // Calculate stats for each player
                    const playerStats = this.players.map(player => {
                        let games = 0;
                        let wins = 0;
                        let draws = 0;
                        let losses = 0;
                        let ratingChanges = [];

                        // Get rating history for this period
                        const relevantHistory = this.ratingsHistory.filter(h => {
                            if (h.playerId !== player.id) return false;
                            const historyDate = new Date(h.date);
                            return historyDate >= startDate && historyDate <= endDate;
                        });

                        filteredMatches.forEach(match => {
                            const inTeamA = match.teamA.includes(player.id);
                            const inTeamB = match.teamB.includes(player.id);

                            if (inTeamA || inTeamB) {
                                games++;
                                if ((inTeamA && match.winner === 'A') || (inTeamB && match.winner === 'B')) {
                                    wins++;
                                } else if (match.winner === 'Draw') {
                                    draws++;
                                } else {
                                    losses++;
                                }
                            }
                        });

                        // Calculate filtered rating based on changes in this period
                        let filteredRating = player.rating;
                        if (relevantHistory.length > 0) {
                            const firstRecord = relevantHistory[0];
                            const lastRecord = relevantHistory[relevantHistory.length - 1];
                            // Start from the rating before the period and add all changes
                            filteredRating = firstRecord.oldRating + relevantHistory.reduce((sum, h) => sum + h.change, 0);
                        }

                        return {
                            ...player,
                            filteredGames: games,
                            filteredWins: wins,
                            filteredDraws: draws,
                            filteredLosses: losses,
                            filteredRating: filteredRating
                        };
                    });

                    // Filter and sort
                    const filtered = playerStats.filter(p => p.filteredGames > 0); // Only show players who played in this period

                    // Apply sorting
                    return [...filtered].sort((a, b) => {
                        let valA, valB;

                        switch(this.leagueSortColumn) {
                            case 'name':
                                valA = a.name.toLowerCase();
                                valB = b.name.toLowerCase();
                                break;
                            case 'points':
                                valA = (a.filteredWins * 3) + (a.filteredDraws * 1);
                                valB = (b.filteredWins * 3) + (b.filteredDraws * 1);
                                break;
                            case 'rating':
                                valA = this.leagueFilter === 'overall' ? a.rating : a.filteredRating;
                                valB = this.leagueFilter === 'overall' ? b.rating : b.filteredRating;
                                break;
                            case 'games':
                                valA = a.filteredGames;
                                valB = b.filteredGames;
                                break;
                            case 'wins':
                                valA = a.filteredWins;
                                valB = b.filteredWins;
                                break;
                            case 'draws':
                                valA = a.filteredDraws;
                                valB = b.filteredDraws;
                                break;
                            case 'losses':
                                valA = a.filteredLosses;
                                valB = b.filteredLosses;
                                break;
                            case 'winpct':
                                valA = a.filteredGames > 0 ? (a.filteredWins + a.filteredDraws * 0.5) / a.filteredGames : 0;
                                valB = b.filteredGames > 0 ? (b.filteredWins + b.filteredDraws * 0.5) / b.filteredGames : 0;
                                break;
                            default:
                                valA = (a.filteredWins * 3) + (a.filteredDraws * 1);
                                valB = (b.filteredWins * 3) + (b.filteredDraws * 1);
                                break;
                        }

                        if (this.leagueSortDirection === 'asc') {
                            return valA > valB ? 1 : valA < valB ? -1 : 0;
                        } else {
                            return valA < valB ? 1 : valA > valB ? -1 : 0;
                        }
                    });
                },

                // Signup Sheet Computed Properties
                sortedGameSessions() {
                    return this.gameSessions
                        .filter(session => session.status === 'active')
                        .slice().sort((a, b) => {
                            const dateComparison = new Date(a.date).getTime() - new Date(b.date).getTime();
                            if (dateComparison !== 0) return dateComparison;
                            return a.time.localeCompare(b.time);
                        });
                }
            },
            watch: {
                historyPlayerFilter() {
                    this.historyCurrentPage = 1; // Reset to first page when filter changes
                },
                historyPageSize() {
                    this.historyCurrentPage = 1; // Reset to first page when page size changes
                },
                leagueFilter() {
                    // Reset league table sorting to default when filter changes
                    this.leagueSortColumn = 'points';
                    this.leagueSortDirection = 'desc';
                },
                viewTournamentId() {
                    // Reset tournament table sorting to default when viewing new tournament
                    this.sortColumn = 'pointDiff';
                    this.sortDirection = 'desc';
                }
            },
            methods: {
                // Site Access Methods
                attemptSiteLogin() {
                    if (this.sitePassword === this.sitePasswordHash) {
                        this.siteAuthenticated = true;
                        this.sitePassword = '';
                        sessionStorage.setItem('siteAuthenticated', 'true');
                    } else {
                        alert('Incorrect password');
                        this.sitePassword = '';
                    }
                },

                // Auth Methods
                attemptLogin() {
                    if (this.adminPassword === this.adminPasswordHash) {
                        this.isAdmin = true;
                        this.showAdminLogin = false;
                        this.adminPassword = '';
                        localStorage.setItem('isAdmin', 'true');
                    } else {
                        alert('Incorrect password');
                    }
                },
                logout() {
                    this.isAdmin = false;
                    localStorage.removeItem('isAdmin');
                    this.activeTab = 'league';
                },

                // Player Methods
                generatePlayerId() {
                    // Find the highest existing player number to avoid ID collisions
                    let maxNum = 0;
                    this.players.forEach(player => {
                        const match = player.id.match(/^P(\d+)$/);
                        if (match) {
                            const num = parseInt(match[1], 10);
                            if (num > maxNum) maxNum = num;
                        }
                    });
                    return 'P' + String(maxNum + 1).padStart(3, '0');
                },
                addPlayer() {
                    if (!this.newPlayer.name) {
                        alert('Please enter a player name');
                        return;
                    }
                    
                    const player = {
                        id: this.generatePlayerId(),
                        name: this.newPlayer.name,
                        rating: this.newPlayer.rating || 200,
                        gamesPlayed: 0,
                        wins: 0,
                        losses: 0,
                        createdAt: new Date().toISOString().split('T')[0]
                    };
                    
                    this.players.push(player);
                    this.saveData();
                    this.cancelAddPlayer();
                },
                cancelAddPlayer() {
                    this.showAddPlayer = false;
                    this.newPlayer = { name: '', rating: 200 };
                },
                editPlayer(player) {
                    const newName = prompt('Enter new name:', player.name);
                    if (newName && newName !== player.name) {
                        player.name = newName;
                        this.saveData();
                    }
                },
                async deletePlayer(playerId) {
                    if (confirm('Are you sure? This will delete all related match history and schedules.')) {
                        try {
                            // Delete from Supabase first
                            const deleteResults = await Promise.all([
                                sb.from('players').delete().eq('id', playerId),
                                sb.from('matches').delete().or(`teamA.cs.{${playerId}},teamB.cs.{${playerId}}`),
                                sb.from('ratings_history').delete().eq('playerId', playerId),
                                sb.from('schedules').delete().or(`teamA.cs.{${playerId}},teamB.cs.{${playerId}}`)
                            ]);
                            
                            // Check for errors
                            deleteResults.forEach((result, index) => {
                                if (result.error) {
                                    const tables = ['players', 'matches', 'ratings_history', 'schedules'];
                                    console.error(`Error deleting from ${tables[index]}:`, result.error);
                                }
                            });
                            
                            // Update local state
                            this.players = this.players.filter(p => p.id !== playerId);
                            this.matches = this.matches.filter(m =>
                                !m.teamA.includes(playerId) && !m.teamB.includes(playerId)
                            );
                            this.ratingsHistory = this.ratingsHistory.filter(r => r.playerId !== playerId);
                            this.schedules = this.schedules.filter(s =>
                                !s.teamA.includes(playerId) && !s.teamB.includes(playerId)
                            );
                            
                            console.log(`Player ${playerId} deleted successfully`);
                        } catch (error) {
                            console.error('Error deleting player:', error);
                            alert('Failed to delete player. Please try again.');
                        }
                    }
                },
                async deleteTournament(tournamentId) {
                    const schedulesToDelete = this.schedules.filter(s => (s.tournamentId || s.date) === tournamentId);
                    const matchesToDelete = this.matches.filter(m => (m.tournamentId || m.date) === tournamentId);

                    const dateStr = schedulesToDelete.length > 0 ? this.formatDate(schedulesToDelete[0].date) : 'Unknown';
                    const confirmMsg = `Delete entire tournament for ${dateStr}?\n\n` +
                                      `- ${schedulesToDelete.length} scheduled matches\n` +
                                      `- ${matchesToDelete.length} recorded matches\n` +
                                      `- All associated rating changes will be reverted`;

                    if (!confirm(confirmMsg)) {
                        return;
                    }

                    // Delete from Supabase first
                    const { error: schedulesError } = await sb.from('schedules').delete().eq('tournamentId', tournamentId);
                    if (schedulesError) {
                        console.error('Error deleting schedules:', schedulesError);
                        alert('Error deleting tournament schedules from database');
                        return;
                    }

                    // Delete ratings history for all matches in this tournament
                    const matchIds = matchesToDelete.map(m => m.id);
                    if (matchIds.length > 0) {
                        const { error: historyError } = await sb.from('ratings_history').delete().in('matchId', matchIds);
                        if (historyError) {
                            console.error('Error deleting ratings history:', historyError);
                            alert('Error deleting tournament ratings history from database');
                            return;
                        }
                    }

                    // Delete matches last (after ratings history)
                    const { error: matchesError } = await sb.from('matches').delete().eq('tournamentId', tournamentId);
                    if (matchesError) {
                        console.error('Error deleting matches:', matchesError);
                        alert('Error deleting tournament matches from database');
                        return;
                    }

                    // Delete schedules
                    this.schedules = this.schedules.filter(s => (s.tournamentId || s.date) !== tournamentId);

                    // Revert ratings for deleted matches
                    const playerRatings = {};
                    matchesToDelete.forEach(match => {
                        [...match.teamA, ...match.teamB].forEach(playerId => {
                            if (!playerRatings[playerId]) {
                                const player = this.players.find(p => p.id === playerId);
                                if (player) {
                                    playerRatings[playerId] = player.rating;
                                }
                            }
                        });
                    });

                    // Delete matches
                    this.matches = this.matches.filter(m => (m.tournamentId || m.date) !== tournamentId);

                    // Get the date for history filtering
                    const tournamentDate = schedulesToDelete.length > 0 ? schedulesToDelete[0].date : null;

                    // Revert ratings
                    Object.keys(playerRatings).forEach(playerId => {
                        const player = this.players.find(p => p.id === playerId);
                        if (player && tournamentDate) {
                            const lastRating = this.ratingsHistory
                                .filter(r => r.playerId === playerId &&
                                       new Date(r.date) < new Date(tournamentDate))
                                .sort((a, b) => new Date(b.date) - new Date(a.date))[0];

                            player.rating = lastRating ? lastRating.ratingAfter : 200;
                        }
                    });

                    // Clean up rating history
                    if (tournamentDate) {
                        this.ratingsHistory = this.ratingsHistory.filter(r => r.tournamentId !== tournamentId);
                    }

                    // Recalculate wins/losses
                    this.players.forEach(player => {
                        const playerMatches = this.matches.filter(m =>
                            m.teamA.includes(player.id) || m.teamB.includes(player.id)
                        );
                        player.wins = 0;
                        player.losses = 0;
                        playerMatches.forEach(match => {
                            const isTeamA = match.teamA.includes(player.id);
                            const won = (isTeamA && match.scoreA > match.scoreB) ||
                                       (!isTeamA && match.scoreB > match.scoreA);
                            if (won) player.wins++;
                            else player.losses++;
                        });
                    });

                    await this.saveData();
                    alert('Tournament deleted successfully');
                },
                endTournament(tournamentId) {
                    const schedulesToEnd = this.schedules.filter(s => (s.tournamentId || s.date) === tournamentId);
                    const matchesToProcess = this.matches.filter(m => (m.tournamentId || m.date) === tournamentId && !m.processed);

                    const dateStr = schedulesToEnd.length > 0 ? this.formatDate(schedulesToEnd[0].date) : 'Unknown';
                    const confirmMsg = `End tournament for ${dateStr}?\n\n` +
                                      `- ${schedulesToEnd.length} scheduled matches will be removed\n` +
                                      `- ${matchesToProcess.length} unprocessed matches will have ratings processed\n` +
                                      `- Tournament leaderboard will be finalized\n` +
                                      `- All matches are saved in history`;

                    if (!confirm(confirmMsg)) {
                        return;
                    }

                    // Process any remaining unprocessed matches
                    if (matchesToProcess.length > 0) {
                        this.processAllRatings();
                    }

                    // Finalize tournament snapshot
                    this.finalizeTournamentSnapshot(tournamentId);

                    // Remove schedules for this tournament
                    this.schedules = this.schedules.filter(s => (s.tournamentId || s.date) !== tournamentId);

                    this.saveData();
                    alert('Tournament ended successfully! All matches saved to history and leaderboard finalized.');
                },

                // Match Methods
                generateMatchId() {
                    // Find the highest existing match number to avoid duplicates
                    let maxNum = 0;
                    this.matches.forEach(match => {
                        if (match.id && match.id.startsWith('M')) {
                            const num = parseInt(match.id.substring(1));
                            if (!isNaN(num) && num > maxNum) {
                                maxNum = num;
                            }
                        }
                    });
                    return 'M' + String(maxNum + 1).padStart(3, '0');
                },
                generateRatingId() {
                    // Find the highest existing rating number to avoid duplicates
                    let maxNum = 0;
                    this.ratingsHistory.forEach(rating => {
                        if (rating.id && rating.id.startsWith('R')) {
                            const num = parseInt(rating.id.substring(1));
                            if (!isNaN(num) && num > maxNum) {
                                maxNum = num;
                            }
                        }
                    });
                    return 'R' + String(maxNum + 1).padStart(3, '0');
                },
                saveMatch() {
                    // Validation
                    if (this.newMatch.teamA.length === 0 || this.newMatch.teamB.length === 0) {
                        alert('Please select players for both teams');
                        return;
                    }
                    
                    // Check for duplicate players
                    const allPlayers = [...this.newMatch.teamA, ...this.newMatch.teamB];
                    if (new Set(allPlayers).size !== allPlayers.length) {
                        alert('A player cannot be on both teams');
                        return;
                    }
                    
                    // Validate format
                    if (this.newMatch.format === 'singles' && (this.newMatch.teamA.length !== 1 || this.newMatch.teamB.length !== 1)) {
                        alert('Singles requires exactly 1 player per team');
                        return;
                    }
                    if (this.newMatch.format === 'doubles' && (this.newMatch.teamA.length !== 2 || this.newMatch.teamB.length !== 2)) {
                        alert('Doubles requires exactly 2 players per team');
                        return;
                    }
                    if (this.newMatch.format === '2v1' && 
                        !((this.newMatch.teamA.length === 2 && this.newMatch.teamB.length === 1) || 
                          (this.newMatch.teamA.length === 1 && this.newMatch.teamB.length === 2))) {
                        alert('2v1 requires 2 players on one team and 1 on the other');
                        return;
                    }
                    
                    const match = {
                        id: this.generateMatchId(),
                        date: this.newMatch.date,
                        format: this.newMatch.format,
                        teamA: [...this.newMatch.teamA],
                        teamB: [...this.newMatch.teamB],
                        scoreA: this.newMatch.scoreA,
                        scoreB: this.newMatch.scoreB,
                        winner: this.newMatch.scoreA > this.newMatch.scoreB ? 'A' :
                                this.newMatch.scoreB > this.newMatch.scoreA ? 'B' : 'Draw',
                        processed: false,
                        notes: this.newMatch.notes
                    };
                    
                    this.matches.push(match);
                    
                    // Auto-process this match immediately
                    this.processMatch(match);
                    
                    this.saveData();
                    
                    // Reset form
                    this.newMatch = {
                        format: 'doubles',
                        date: new Date().toISOString().split('T')[0],
                        teamA: [],
                        teamB: [],
                        scoreA: 0,
                        scoreB: 0,
                        notes: '',
                        scheduleId: null
                    };
                    
                    alert('Match saved and ratings updated!');
                },

                // Rating Methods
                calculateElo(ratingA, ratingB, scoreA, scoreB, kFactor = 32) {
                    const expectedA = 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));
                    const actualA = scoreA > scoreB ? 1 : scoreA < scoreB ? 0 : 0.5; // 1 for win, 0 for loss, 0.5 for draw
                    const changeA = kFactor * (actualA - expectedA);
                    return {
                        changeA: changeA,
                        changeB: -changeA
                    };
                },
                processMatch(match) {
                    if (match.processed) return; // Already processed
                    
                    // Get team ratings
                    const teamAPlayers = match.teamA.map(id => this.players.find(p => p.id === id));
                    const teamBPlayers = match.teamB.map(id => this.players.find(p => p.id === id));
                    
                    const teamARating = teamAPlayers.reduce((sum, p) => sum + p.rating, 0) / teamAPlayers.length;
                    const teamBRating = teamBPlayers.reduce((sum, p) => sum + p.rating, 0) / teamBPlayers.length;
                    
                    // Calculate rating changes
                    const changes = this.calculateElo(teamARating, teamBRating, match.scoreA, match.scoreB);
                    
                    // Update player ratings and stats
                    teamAPlayers.forEach(player => {
                        const oldRating = player.rating;
                        player.rating = Math.max(0, player.rating + changes.changeA);
                        player.gamesPlayed++;
                        if (match.winner === 'A') player.wins++;
                        else if (match.winner === 'Draw') player.draws = (player.draws || 0) + 1;
                        else player.losses++;

                        // Add to history
                        this.ratingsHistory.push({
                            id: this.generateRatingId(),
                            playerId: player.id,
                            matchId: match.id,
                            oldRating: oldRating,
                            newRating: player.rating,
                            change: changes.changeA,
                            date: match.date
                        });
                    });

                    teamBPlayers.forEach(player => {
                        const oldRating = player.rating;
                        player.rating = Math.max(0, player.rating + changes.changeB);
                        player.gamesPlayed++;
                        if (match.winner === 'B') player.wins++;
                        else if (match.winner === 'Draw') player.draws = (player.draws || 0) + 1;
                        else player.losses++;

                        // Add to history
                        this.ratingsHistory.push({
                            id: this.generateRatingId(),
                            playerId: player.id,
                            matchId: match.id,
                            oldRating: oldRating,
                            newRating: player.rating,
                            change: changes.changeB,
                            date: match.date
                        });
                    });
                    
                    match.processed = true;
                },
                processAllMatches() {
                    const unprocessed = this.matches.filter(m => !m.processed);

                    unprocessed.forEach(match => {
                        // Get team ratings
                        const teamAPlayers = match.teamA.map(id => this.players.find(p => p.id === id));
                        const teamBPlayers = match.teamB.map(id => this.players.find(p => p.id === id));

                        const teamARating = teamAPlayers.reduce((sum, p) => sum + p.rating, 0) / teamAPlayers.length;
                        const teamBRating = teamBPlayers.reduce((sum, p) => sum + p.rating, 0) / teamBPlayers.length;

                        // Calculate rating changes
                        const changes = this.calculateElo(teamARating, teamBRating, match.scoreA, match.scoreB);

                        // Update player ratings and stats
                        teamAPlayers.forEach(player => {
                            const oldRating = player.rating;
                            player.rating = Math.max(0, player.rating + changes.changeA);
                            player.gamesPlayed++;
                            if (match.winner === 'A') player.wins++;
                            else if (match.winner === 'Draw') player.draws = (player.draws || 0) + 1;
                            else player.losses++;

                            // Add to history
                            this.ratingsHistory.push({
                                id: this.generateRatingId(),
                                playerId: player.id,
                                matchId: match.id,
                                oldRating: oldRating,
                                newRating: player.rating,
                                change: changes.changeA,
                                date: match.date
                            });
                        });

                        teamBPlayers.forEach(player => {
                            const oldRating = player.rating;
                            player.rating = Math.max(0, player.rating + changes.changeB);
                            player.gamesPlayed++;
                            if (match.winner === 'B') player.wins++;
                            else if (match.winner === 'Draw') player.draws = (player.draws || 0) + 1;
                            else player.losses++;

                            // Add to history
                            this.ratingsHistory.push({
                                id: this.generateRatingId(),
                                playerId: player.id,
                                matchId: match.id,
                                oldRating: oldRating,
                                newRating: player.rating,
                                change: changes.changeB,
                                date: match.date
                            });
                        });

                        match.processed = true;
                    });

                    this.saveData();
                    alert(`Processed ${unprocessed.length} matches and updated ratings!`);
                },

                // Helper methods for schedule generation
                getPartnershipKey(p1, p2) {
                    return [p1, p2].sort().join('-');
                },
                getMatchupKey(team1, team2) {
                    return [team1.sort().join(','), team2.sort().join(',')].sort().join('|');
                },
                countPartnerships(schedules, matches) {
                    const partnerships = {};
                    const allGames = [...schedules, ...matches.filter(m => m.processed)];

                    allGames.forEach(game => {
                        if (game.format === 'doubles' || (game.format === '2v1' && game.teamA.length === 2)) {
                            if (game.teamA.length === 2) {
                                const key = this.getPartnershipKey(game.teamA[0], game.teamA[1]);
                                partnerships[key] = (partnerships[key] || 0) + 1;
                            }
                            if (game.teamB.length === 2) {
                                const key = this.getPartnershipKey(game.teamB[0], game.teamB[1]);
                                partnerships[key] = (partnerships[key] || 0) + 1;
                            }
                        }
                    });

                    return partnerships;
                },
                countOpponents(schedules, matches) {
                    const opponents = {};
                    const allGames = [...schedules, ...matches.filter(m => m.processed)];

                    allGames.forEach(game => {
                        game.teamA.forEach(p1 => {
                            game.teamB.forEach(p2 => {
                                const key = this.getPartnershipKey(p1, p2);
                                opponents[key] = (opponents[key] || 0) + 1;
                            });
                        });
                    });

                    return opponents;
                },
                countSitOuts(schedules) {
                    const sitOuts = {};
                    const allPlayerIds = this.scheduleGenerator.availablePlayers;

                    allPlayerIds.forEach(id => sitOuts[id] = 0);

                    schedules.forEach(schedule => {
                        if (schedule.date === this.scheduleGenerator.date) {
                            const playingIds = [...schedule.teamA, ...schedule.teamB];
                            allPlayerIds.forEach(id => {
                                if (!playingIds.includes(id)) {
                                    sitOuts[id] = (sitOuts[id] || 0) + 1;
                                }
                            });
                        }
                    });

                    return sitOuts;
                },

                // Tournament Generation (Multiple Rounds)
                generateTournament() {
                    const available = [...this.scheduleGenerator.availablePlayers];
                    const format = this.scheduleGenerator.format;
                    const numCourts = this.scheduleGenerator.courts;
                    const numRounds = this.scheduleGenerator.tournamentRounds || 10;
                    const keepSamePairings = this.scheduleGenerator.keepSamePairings;

                    if (format !== 'doubles') {
                        alert('Tournament generator currently only supports doubles format');
                        return;
                    }

                    if (available.length < 4) {
                        alert('Need at least 4 players for doubles tournament');
                        return;
                    }

                    const playerObjs = available.map(id => this.players.find(p => p.id === id));
                    const allRoundsSchedule = [];

                    // Track partnerships and opponents across ALL rounds
                    const tournamentPartnerships = {};
                    const tournamentOpponents = {};
                    const sitOutCounts = {};
                    const lastSatOutRound = {}; // Track which round each player last sat out
                    const fixedPairings = []; // Store fixed partnerships if keepSamePairings is true

                    playerObjs.forEach(p => {
                        sitOutCounts[p.id] = 0;
                        lastSatOutRound[p.id] = -10; // Initialize to far in past
                    });

                    for (let roundNum = 1; roundNum <= numRounds; roundNum++) {
                        const roundMatches = [];
                        const playersThisRound = [...playerObjs];

                        // Determine sit-outs for this round (prioritize those who sat out least)
                        const playersNeeded = numCourts * 4;
                        const sitOutsNeeded = playersThisRound.length - playersNeeded;

                        const sitOutsThisRound = [];
                        if (sitOutsNeeded > 0) {
                            // Filter out anyone who sat out in the previous round
                            const eligibleToSitOut = playersThisRound.filter(p =>
                                lastSatOutRound[p.id] < roundNum - 1
                            );

                            // If not enough eligible players (shouldn't happen with 10 players, 2 courts)
                            // fall back to all players
                            const candidatePool = eligibleToSitOut.length >= sitOutsNeeded
                                ? eligibleToSitOut
                                : playersThisRound;

                            // Sort by sit-out count (ascending) then by last sat-out round (ascending)
                            const sorted = [...candidatePool].sort((a, b) => {
                                const countDiff = sitOutCounts[a.id] - sitOutCounts[b.id];
                                if (countDiff !== 0) return countDiff;
                                return lastSatOutRound[a.id] - lastSatOutRound[b.id];
                            });

                            // Take the first N players (those with fewest sit-outs and oldest sit-out)
                            for (let i = 0; i < sitOutsNeeded; i++) {
                                const sitOut = sorted[i];
                                sitOutsThisRound.push(sitOut);
                                sitOutCounts[sitOut.id]++;
                                lastSatOutRound[sitOut.id] = roundNum;
                                playersThisRound.splice(playersThisRound.indexOf(sitOut), 1);
                            }
                        }

                        // Generate matches for this round
                        let attempts = 0;
                        let validRound = false;

                        while (!validRound && attempts < 100) {
                            attempts++;
                            let testMatches = [];
                            let valid = true;

                            if (keepSamePairings) {
                                // Fixed pairings mode
                                if (roundNum === 1) {
                                    // First round: establish pairings
                                    const shuffled = this.shuffleArray([...playersThisRound]);

                                    for (let court = 0; court < numCourts && shuffled.length >= 4; court++) {
                                        const team1 = [shuffled.shift(), shuffled.shift()];
                                        const team2 = [shuffled.shift(), shuffled.shift()];

                                        // Store these as fixed pairings
                                        fixedPairings.push(team1, team2);

                                        testMatches.push({
                                            court: court + 1,
                                            team1: team1,
                                            team2: team2
                                        });
                                    }
                                } else {
                                    // Subsequent rounds: use fixed pairings, rotate opponents
                                    const availablePairings = [];

                                    // Get pairings for players who are playing this round
                                    playersThisRound.forEach(player => {
                                        const pairing = fixedPairings.find(p =>
                                            p[0].id === player.id || p[1].id === player.id
                                        );
                                        if (pairing && !availablePairings.some(ap =>
                                            (ap[0].id === pairing[0].id && ap[1].id === pairing[1].id) ||
                                            (ap[0].id === pairing[1].id && ap[1].id === pairing[0].id)
                                        )) {
                                            availablePairings.push(pairing);
                                        }
                                    });

                                    const shuffledPairings = this.shuffleArray([...availablePairings]);

                                    for (let court = 0; court < numCourts && shuffledPairings.length >= 2; court++) {
                                        const team1 = shuffledPairings.shift();
                                        const team2 = shuffledPairings.shift();

                                        testMatches.push({
                                            court: court + 1,
                                            team1: team1,
                                            team2: team2
                                        });
                                    }
                                }
                            } else {
                                // Original rotating partners mode
                                const shuffled = this.shuffleArray([...playersThisRound]);

                                for (let court = 0; court < numCourts && shuffled.length >= 4; court++) {
                                    const four = shuffled.splice(0, 4);

                                    // Try different team combinations
                                    const combos = [
                                        [[four[0], four[1]], [four[2], four[3]]],
                                        [[four[0], four[2]], [four[1], four[3]]],
                                        [[four[0], four[3]], [four[1], four[2]]]
                                    ];

                                    let bestCombo = null;
                                    let bestScore = Infinity;

                                    for (const [team1, team2] of combos) {
                                        const p1Key = this.getPartnershipKey(team1[0].id, team1[1].id);
                                        const p2Key = this.getPartnershipKey(team2[0].id, team2[1].id);

                                        // Check if partnerships are fresh
                                        const p1Count = tournamentPartnerships[p1Key] || 0;
                                        const p2Count = tournamentPartnerships[p2Key] || 0;

                                        // Calculate opponent frequency
                                        let oppScore = 0;
                                        team1.forEach(t1 => {
                                            team2.forEach(t2 => {
                                                const oppKey = this.getPartnershipKey(t1.id, t2.id);
                                                oppScore += (tournamentOpponents[oppKey] || 0);
                                            });
                                        });

                                        const totalScore = (p1Count + p2Count) * 100 + oppScore * 10;

                                        if (totalScore < bestScore) {
                                            bestScore = totalScore;
                                            bestCombo = [team1, team2];
                                        }
                                    }

                                    if (bestCombo) {
                                        testMatches.push({
                                            court: court + 1,
                                            team1: bestCombo[0],
                                            team2: bestCombo[1]
                                        });
                                    }
                                }
                            }

                            if (testMatches.length === numCourts) {
                                validRound = true;

                                // Update tracking
                                testMatches.forEach(match => {
                                    const p1Key = this.getPartnershipKey(match.team1[0].id, match.team1[1].id);
                                    const p2Key = this.getPartnershipKey(match.team2[0].id, match.team2[1].id);

                                    // Only track partnerships if not using fixed pairings
                                    if (!keepSamePairings) {
                                        tournamentPartnerships[p1Key] = (tournamentPartnerships[p1Key] || 0) + 1;
                                        tournamentPartnerships[p2Key] = (tournamentPartnerships[p2Key] || 0) + 1;
                                    }

                                    match.team1.forEach(t1 => {
                                        match.team2.forEach(t2 => {
                                            const oppKey = this.getPartnershipKey(t1.id, t2.id);
                                            tournamentOpponents[oppKey] = (tournamentOpponents[oppKey] || 0) + 1;
                                        });
                                    });

                                    const team1Rating = (match.team1[0].rating + match.team1[1].rating) / 2;
                                    const team2Rating = (match.team2[0].rating + match.team2[1].rating) / 2;

                                    allRoundsSchedule.push({
                                        roundNumber: roundNum,
                                        court: match.court,
                                        format: 'doubles',
                                        teamA: match.team1.map(p => p.id),
                                        teamANames: match.team1.map(p => p.name).join(' & '),
                                        teamARating: team1Rating,
                                        teamB: match.team2.map(p => p.id),
                                        teamBNames: match.team2.map(p => p.name).join(' & '),
                                        teamBRating: team2Rating,
                                        ratingDiff: Math.abs(team1Rating - team2Rating).toFixed(0),
                                        sitOuts: sitOutsThisRound.map(p => ({ id: p.id, name: p.name }))
                                    });
                                });
                            }
                        }

                        if (!validRound) {
                            alert(`Could not generate valid round ${roundNum}. Try with different parameters.`);
                            return;
                        }
                    }

                    this.generatedSchedule = allRoundsSchedule;
                    const pairingsMsg = keepSamePairings ? ' with fixed pairings' : ' with rotating partners';
                    alert(`Generated ${numRounds}-round tournament successfully${pairingsMsg}!`);
                },

                // Schedule Methods
                generateSchedule() {
                    const available = [...this.scheduleGenerator.availablePlayers];
                    const format = this.scheduleGenerator.format;
                    const numCourts = this.scheduleGenerator.courts;

                    // Validation based on format
                    if (format === 'singles') {
                        if (available.length < 2) {
                            alert('Need at least 2 players for singles matches');
                            return;
                        }
                    } else if (format === 'doubles') {
                        if (available.length < 4) {
                            alert('Need at least 4 players for doubles matches');
                            return;
                        }
                    } else if (format === '2v1') {
                        if (available.length < 3) {
                            alert('Need at least 3 players for 2v1 matches');
                            return;
                        }
                    }

                    // Get player objects
                    const playerObjs = available.map(id => this.players.find(p => p.id === id));

                    // Get historical data
                    const partnerships = this.countPartnerships(this.schedules, this.matches);
                    const opponents = this.countOpponents(this.schedules, this.matches);
                    const sitOuts = this.countSitOuts(this.schedules);

                    let bestSchedule = null;
                    let bestScore = Infinity;
                    const maxAttempts = 1000;

                    // Try multiple times to find best schedule
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                        const result = this.generateScheduleAttempt(
                            playerObjs, format, numCourts, partnerships, opponents, sitOuts
                        );

                        if (result && result.score < bestScore) {
                            bestScore = result.score;
                            bestSchedule = result.schedule;
                        }

                        // If we found a perfect solution, stop
                        if (bestScore === 0) break;
                    }

                    if (bestSchedule) {
                        this.generatedSchedule = bestSchedule.matches;
                        this.scheduleGenerator.sitOut = bestSchedule.sitOut;
                    } else {
                        alert('Could not generate a valid schedule. Try adjusting the number of courts or players.');
                    }
                },

                generateScheduleAttempt(playerObjs, format, numCourts, partnerships, opponents, sitOuts) {
                    const players = [...playerObjs];
                    players.sort((a, b) => b.rating - a.rating);

                    let sitOutPlayer = null;
                    const playersNeeded = format === 'singles' ? numCourts * 2 :
                                         format === 'doubles' ? numCourts * 4 :
                                         numCourts * 3;

                    // Determine who sits out (if anyone)
                    if (players.length > playersNeeded) {
                        // Pick player with most sit-outs to play this time (fairness)
                        const leastSitOuts = Math.min(...players.map(p => sitOuts[p.id] || 0));
                        const candidatesToSitOut = players.filter(p => (sitOuts[p.id] || 0) === leastSitOuts);
                        const randomIndex = Math.floor(Math.random() * candidatesToSitOut.length);
                        sitOutPlayer = candidatesToSitOut[randomIndex];
                        players.splice(players.indexOf(sitOutPlayer), 1);
                    } else if (players.length < playersNeeded) {
                        // Not enough players for all courts
                        return null;
                    }

                    const matches = [];
                    const tempPartnerships = {...partnerships};
                    const tempOpponents = {...opponents};
                    let score = 0;

                    if (format === 'doubles') {
                        // Generate doubles matches
                        const shuffled = this.shuffleArray([...players]);

                        for (let court = 0; court < numCourts && shuffled.length >= 4; court++) {
                            // Try to create balanced teams
                            const bestMatch = this.findBestDoublesMatch(
                                shuffled, tempPartnerships, tempOpponents
                            );

                            if (!bestMatch) return null;

                            const {team1, team2, matchScore} = bestMatch;
                            score += matchScore;

                            // Remove players from pool
                            team1.forEach(p => shuffled.splice(shuffled.indexOf(p), 1));
                            team2.forEach(p => shuffled.splice(shuffled.indexOf(p), 1));

                            // Update temp tracking
                            const p1Key = this.getPartnershipKey(team1[0].id, team1[1].id);
                            const p2Key = this.getPartnershipKey(team2[0].id, team2[1].id);
                            tempPartnerships[p1Key] = (tempPartnerships[p1Key] || 0) + 1;
                            tempPartnerships[p2Key] = (tempPartnerships[p2Key] || 0) + 1;

                            team1.forEach(p1 => {
                                team2.forEach(p2 => {
                                    const oppKey = this.getPartnershipKey(p1.id, p2.id);
                                    tempOpponents[oppKey] = (tempOpponents[oppKey] || 0) + 1;
                                });
                            });

                            const team1Rating = (team1[0].rating + team1[1].rating) / 2;
                            const team2Rating = (team2[0].rating + team2[1].rating) / 2;

                            matches.push({
                                teamA: team1.map(p => p.id),
                                teamANames: team1.map(p => p.name).join(' & '),
                                teamARating: team1Rating,
                                teamB: team2.map(p => p.id),
                                teamBNames: team2.map(p => p.name).join(' & '),
                                teamBRating: team2Rating,
                                ratingDiff: Math.abs(team1Rating - team2Rating).toFixed(0),
                                format: 'doubles',
                                court: court + 1
                            });
                        }
                    } else if (format === 'singles') {
                        // Generate singles matches
                        const shuffled = this.shuffleArray([...players]);

                        for (let court = 0; court < numCourts && shuffled.length >= 2; court++) {
                            const p1 = shuffled.shift();
                            const p2 = shuffled.shift();

                            const oppKey = this.getPartnershipKey(p1.id, p2.id);
                            const oppCount = tempOpponents[oppKey] || 0;
                            score += oppCount * 10;
                            tempOpponents[oppKey] = oppCount + 1;

                            const ratingDiff = Math.abs(p1.rating - p2.rating);
                            if (ratingDiff > 150) score += (ratingDiff - 150);

                            matches.push({
                                teamA: [p1.id],
                                teamANames: p1.name,
                                teamARating: p1.rating,
                                teamB: [p2.id],
                                teamBNames: p2.name,
                                teamBRating: p2.rating,
                                ratingDiff: ratingDiff.toFixed(0),
                                format: 'singles',
                                court: court + 1
                            });
                        }
                    }

                    return {
                        schedule: {
                            matches: matches,
                            sitOut: sitOutPlayer ? sitOutPlayer.id : null
                        },
                        score: score
                    };
                },

                findBestDoublesMatch(players, partnerships, opponents) {
                    let bestMatch = null;
                    let bestScore = Infinity;
                    const maxTries = Math.min(50, players.length * players.length);

                    for (let i = 0; i < maxTries; i++) {
                        // Pick 4 random players
                        const shuffled = this.shuffleArray([...players]);
                        if (shuffled.length < 4) return null;

                        const four = shuffled.slice(0, 4);

                        // Try different team combinations
                        const combinations = [
                            [[four[0], four[1]], [four[2], four[3]]],
                            [[four[0], four[2]], [four[1], four[3]]],
                            [[four[0], four[3]], [four[1], four[2]]]
                        ];

                        for (const [team1, team2] of combinations) {
                            const score = this.scoreDoublesMatch(team1, team2, partnerships, opponents);

                            if (score < bestScore) {
                                bestScore = score;
                                bestMatch = {team1, team2, matchScore: score};
                            }
                        }
                    }

                    return bestMatch;
                },

                scoreDoublesMatch(team1, team2, partnerships, opponents) {
                    let score = 0;

                    // Check partnership constraints
                    const p1Key = this.getPartnershipKey(team1[0].id, team1[1].id);
                    const p2Key = this.getPartnershipKey(team2[0].id, team2[1].id);

                    const p1Count = partnerships[p1Key] || 0;
                    const p2Count = partnerships[p2Key] || 0;

                    // Penalize partnerships used more than twice
                    if (p1Count >= 2) score += (p1Count - 1) * 100;
                    if (p2Count >= 2) score += (p2Count - 1) * 100;

                    // Check opponent frequency
                    team1.forEach(p1 => {
                        team2.forEach(p2 => {
                            const oppKey = this.getPartnershipKey(p1.id, p2.id);
                            const oppCount = opponents[oppKey] || 0;
                            score += oppCount * 10;
                        });
                    });

                    // Check rating difference
                    const team1Rating = (team1[0].rating + team1[1].rating) / 2;
                    const team2Rating = (team2[0].rating + team2[1].rating) / 2;
                    const ratingDiff = Math.abs(team1Rating - team2Rating);

                    if (ratingDiff > 150) {
                        score += (ratingDiff - 150) * 2;
                    }

                    return score;
                },

                shuffleArray(array) {
                    const arr = [...array];
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                },
                async saveGeneratedSchedule() {
                    try {
                        console.log('saveGeneratedSchedule called');
                        console.log('Generated schedule:', this.generatedSchedule);

                        if (this.generatedSchedule.length === 0) {
                            alert('No schedule to save. Please generate a schedule first.');
                            return;
                        }

                        // Generate unique tournament ID based on timestamp
                        const tournamentId = 'T' + Date.now();
                        console.log('Tournament ID:', tournamentId);

                        // Find the highest existing schedule ID number to avoid conflicts
                        const existingIds = this.schedules.map(s => {
                            const match = s.id.match(/^S(\d+)$/);
                            return match ? parseInt(match[1]) : 0;
                        });
                        const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;

                        let scheduleIndex = 0;
                        this.generatedSchedule.forEach(match => {
                            const schedule = {
                                id: 'S' + String(maxId + scheduleIndex + 1).padStart(4, '0'),
                                tournamentId: tournamentId,
                                date: this.scheduleGenerator.date,
                                court: match.court,
                                format: match.format,
                                teamA: match.teamA,
                                teamB: match.teamB,
                                rounds: this.scheduleGenerator.rounds || 1,
                                roundNumber: match.roundNumber || 1,
                                notes: this.scheduleGenerator.notes
                            };
                            this.schedules.push(schedule);
                            scheduleIndex++;
                        });

                        console.log('Schedules added to array, total schedules:', this.schedules.length);

                        // Create tournament snapshot
                        this.createTournamentSnapshot(tournamentId, this.scheduleGenerator.date, this.scheduleGenerator.notes);

                        console.log('About to call saveData...');
                        await this.saveData();
                        console.log('saveData completed');

                        this.generatedSchedule = [];
                        this.scheduleGenerator.availablePlayers = [];
                        alert('Schedule saved successfully!');
                    } catch (error) {
                        console.error('Error in saveGeneratedSchedule:', error);
                        alert('Error saving schedule: ' + error.message);
                    }
                },
                resetManualMatchPlayers() {
                    if (this.manualMatch.format === 'singles') {
                        this.manualMatch.teamA = [''];
                        this.manualMatch.teamB = [''];
                    } else if (this.manualMatch.format === 'doubles') {
                        this.manualMatch.teamA = ['', ''];
                        this.manualMatch.teamB = ['', ''];
                    } else if (this.manualMatch.format === '2v1') {
                        this.manualMatch.teamA = ['', ''];
                        this.manualMatch.teamB = [''];
                    }
                },
                saveManualMatch() {
                    // Filter out empty selections
                    const teamA = this.manualMatch.teamA.filter(p => p !== '');
                    const teamB = this.manualMatch.teamB.filter(p => p !== '');

                    // Validation
                    if (teamA.length === 0 || teamB.length === 0) {
                        alert('Please select players for both teams');
                        return;
                    }

                    // Check for duplicate players
                    const allPlayers = [...teamA, ...teamB];
                    if (new Set(allPlayers).size !== allPlayers.length) {
                        alert('A player cannot be on both teams');
                        return;
                    }

                    // Validate format
                    if (this.manualMatch.format === 'singles' && (teamA.length !== 1 || teamB.length !== 1)) {
                        alert('Singles requires exactly 1 player per team');
                        return;
                    }
                    if (this.manualMatch.format === 'doubles' && (teamA.length !== 2 || teamB.length !== 2)) {
                        alert('Doubles requires exactly 2 players per team');
                        return;
                    }
                    if (this.manualMatch.format === '2v1' &&
                        !((teamA.length === 2 && teamB.length === 1) ||
                          (teamA.length === 1 && teamB.length === 2))) {
                        alert('2v1 requires 2 players on one team and 1 on the other');
                        return;
                    }

                    // Generate unique tournament ID based on timestamp
                    const tournamentId = 'T' + Date.now();

                    // Find the highest existing schedule ID number to avoid conflicts
                    const existingIds = this.schedules.map(s => {
                        const match = s.id.match(/^S(\d+)$/);
                        return match ? parseInt(match[1]) : 0;
                    });
                    const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;

                    const schedule = {
                        id: 'S' + String(maxId + 1).padStart(4, '0'),
                        tournamentId: tournamentId,
                        date: this.manualMatch.date,
                        court: this.manualMatch.court,
                        format: this.manualMatch.format,
                        teamA: teamA,
                        teamB: teamB,
                        rounds: this.manualMatch.rounds || 1,
                        roundNumber: 1,
                        notes: this.manualMatch.notes
                    };

                    this.schedules.push(schedule);

                    // Create tournament snapshot
                    this.createTournamentSnapshot(tournamentId, this.manualMatch.date, this.manualMatch.notes);

                    this.saveData();

                    alert('Match added to schedule successfully!');
                    this.cancelManualMatch();
                },
                cancelManualMatch() {
                    this.showManualMatch = false;
                    this.manualMatch = {
                        format: 'doubles',
                        date: new Date().toISOString().split('T')[0],
                        court: 1,
                        rounds: 3,
                        teamA: ['', ''],
                        teamB: ['', ''],
                        notes: ''
                    };
                },

                // Custom Tournament Methods
                addCustomRound() {
                    this.customTournament.rounds.push({
                        courts: '',
                        matches: []
                    });
                },

                deleteCustomRound(roundIndex) {
                    if (confirm('Are you sure you want to delete this round?')) {
                        this.customTournament.rounds.splice(roundIndex, 1);
                    }
                },

                addCustomMatch(roundIndex) {
                    const format = this.customTournament.format;
                    const match = {
                        teamA: format === 'singles' ? [''] : ['', ''],
                        teamB: format === 'singles' ? [''] : ['', ''],
                        rounds: 3
                    };

                    // Adjust for 2v1
                    if (format === '2v1') {
                        match.teamA = ['', ''];
                        match.teamB = [''];
                    }

                    this.customTournament.rounds[roundIndex].matches.push(match);
                },

                deleteCustomMatch(roundIndex, matchIndex) {
                    this.customTournament.rounds[roundIndex].matches.splice(matchIndex, 1);
                },

                async saveCustomTournament() {
                    if (!this.customTournament.name) {
                        alert('Please enter a tournament name');
                        return;
                    }

                    if (this.customTournament.rounds.length === 0) {
                        alert('Please add at least one round');
                        return;
                    }

                    // Generate tournament ID
                    const tournamentId = 'T' + Date.now();

                    // Find the highest existing schedule ID number to avoid conflicts
                    const existingIds = this.schedules.map(s => {
                        const match = s.id.match(/^S(\d+)$/);
                        return match ? parseInt(match[1]) : 0;
                    });
                    let maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;

                    // Process each round
                    let scheduleCount = 0;
                    this.customTournament.rounds.forEach((round, roundIndex) => {
                        const courts = round.courts.split(',').map(c => parseInt(c.trim())).filter(c => !isNaN(c));

                        round.matches.forEach((match, matchIndex) => {
                            // Filter out empty selections
                            const teamA = match.teamA.filter(p => p !== '');
                            const teamB = match.teamB.filter(p => p !== '');

                            // Validate teams
                            if (teamA.length === 0 || teamB.length === 0) {
                                return; // Skip incomplete matches
                            }

                            // Assign court
                            const court = courts[matchIndex % courts.length] || matchIndex + 1;

                            // Create schedule entry
                            const schedule = {
                                id: 'S' + String(maxId + scheduleCount + 1).padStart(4, '0'),
                                tournamentId: tournamentId,
                                date: this.customTournament.date,
                                court: court,
                                format: this.customTournament.format,
                                teamA: teamA,
                                teamB: teamB,
                                rounds: match.rounds || 3,
                                roundNumber: roundIndex + 1,
                                notes: this.customTournament.name
                            };

                            this.schedules.push(schedule);
                            scheduleCount++;
                        });
                    });

                    if (scheduleCount === 0) {
                        alert('No valid matches were created. Please fill in the teams.');
                        return;
                    }

                    await this.saveData();
                    alert(`Custom tournament "${this.customTournament.name}" created with ${scheduleCount} matches!`);
                    this.cancelCustomTournament();
                },

                cancelCustomTournament() {
                    this.showCustomTournament = false;
                    this.customTournament = {
                        name: '',
                        date: new Date().toISOString().split('T')[0],
                        format: 'doubles',
                        rounds: []
                    };
                },

                // Match History Methods
                toggleMatchExpand(matchId) {
                    this.expandedMatches[matchId] = !this.expandedMatches[matchId];
                },

                // Edit Match Methods
                openEditMatch(match) {
                    this.editingMatch = match;
                    this.editMatchForm = {
                        scoreA: match.scoreA,
                        scoreB: match.scoreB,
                        date: match.date,
                        notes: match.notes || ''
                    };
                },

                closeEditMatch() {
                    this.editingMatch = null;
                    this.editMatchForm = {
                        scoreA: 0,
                        scoreB: 0,
                        date: '',
                        notes: ''
                    };
                },

                saveMatchEdit() {
                    if (!this.editingMatch) return;

                    // Reverse the original rating changes
                    this.reverseMatchRatings(this.editingMatch);

                    // Update match data
                    this.editingMatch.scoreA = this.editMatchForm.scoreA;
                    this.editingMatch.scoreB = this.editMatchForm.scoreB;
                    this.editingMatch.date = this.editMatchForm.date;
                    this.editingMatch.notes = this.editMatchForm.notes;
                    this.editingMatch.winner = this.editMatchForm.scoreA > this.editMatchForm.scoreB ? 'A' :
                                               this.editMatchForm.scoreB > this.editMatchForm.scoreA ? 'B' : 'Draw';
                    this.editingMatch.processed = false;

                    // Reprocess the match with new scores
                    this.processMatch(this.editingMatch);

                    this.saveData();
                    alert('Match updated successfully!');
                    this.closeEditMatch();
                },

                reverseMatchRatings(match) {
                    // Get team players
                    const teamAPlayers = match.teamA.map(id => this.players.find(p => p.id === id));
                    const teamBPlayers = match.teamB.map(id => this.players.find(p => p.id === id));

                    // Reverse stats
                    teamAPlayers.forEach(player => {
                        player.gamesPlayed--;
                        if (match.winner === 'A') player.wins--;
                        else if (match.winner === 'Draw') player.draws = (player.draws || 1) - 1;
                        else player.losses--;
                    });

                    teamBPlayers.forEach(player => {
                        player.gamesPlayed--;
                        if (match.winner === 'B') player.wins--;
                        else if (match.winner === 'Draw') player.draws = (player.draws || 1) - 1;
                        else player.losses--;
                    });

                    // Reverse rating changes from history
                    const matchHistory = this.ratingsHistory.filter(h => h.matchId === match.id);
                    matchHistory.forEach(historyEntry => {
                        const player = this.players.find(p => p.id === historyEntry.playerId);
                        if (player) {
                            player.rating = historyEntry.oldRating;
                        }
                    });

                    // Remove history entries for this match
                    this.ratingsHistory = this.ratingsHistory.filter(h => h.matchId !== match.id);
                },

                async deleteMatch(match) {
                    if (!confirm(`Are you sure you want to delete this match?\n\n${this.getTeamNames(match.teamA)} vs ${this.getTeamNames(match.teamB)}\n${match.scoreA} - ${match.scoreB}\n\nThis will reverse all rating changes from this match.`)) {
                        return;
                    }

                    // Reverse the ratings
                    this.reverseMatchRatings(match);

                    // Remove the match from the array
                    const index = this.matches.findIndex(m => m.id === match.id);
                    if (index !== -1) {
                        this.matches.splice(index, 1);
                    }

                    // Delete from Supabase
                    try {
                        await sb.from('matches').delete().eq('id', match.id);
                        await sb.from('ratings_history').delete().eq('matchId', match.id);
                        console.log('Match deleted from Supabase');
                    } catch (error) {
                        console.error('Error deleting from Supabase:', error);
                    }

                    this.saveData();
                    alert('Match deleted successfully!');
                },

                // Round Recording Methods
                toggleScheduleExpand(scheduleId) {
                    this.expandedSchedules[scheduleId] = !this.expandedSchedules[scheduleId];

                    // Initialize round scores if not exists
                    if (!this.roundScores[scheduleId]) {
                        this.roundScores[scheduleId] = {};
                    }
                },
                getRoundScore(scheduleId, round, team) {
                    if (!this.roundScores[scheduleId] || !this.roundScores[scheduleId][round]) {
                        return '';
                    }
                    return this.roundScores[scheduleId][round][team] || '';
                },
                updateRoundScore(scheduleId, round, team, value) {
                    if (!this.roundScores[scheduleId]) {
                        this.roundScores[scheduleId] = {};
                    }
                    if (!this.roundScores[scheduleId][round]) {
                        this.roundScores[scheduleId][round] = { A: '', B: '', saved: false };
                    }
                    this.roundScores[scheduleId][round][team] = value;
                },
                saveRound(scheduleId, round) {
                    if (!this.roundScores[scheduleId] || !this.roundScores[scheduleId][round]) return;

                    const scoreA = this.roundScores[scheduleId][round].A;
                    const scoreB = this.roundScores[scheduleId][round].B;

                    if (scoreA === '' || scoreB === '') {
                        alert('Please enter both scores');
                        return;
                    }

                    this.roundScores[scheduleId][round].saved = true;
                },
                isRoundSaved(scheduleId, round) {
                    return this.roundScores[scheduleId]?.[round]?.saved || false;
                },
                toggleSessionExpand(date) {
                    this.expandedSessions[date] = !this.expandedSessions[date];
                },
                toggleRoundExpand(roundKey) {
                    this.expandedRounds[roundKey] = !this.expandedRounds[roundKey];
                },
                saveRoundMatch(match) {
                    const scoreA = parseInt(this.getRoundScore(match.id, 1, 'A')) || 0;
                    const scoreB = parseInt(this.getRoundScore(match.id, 1, 'B')) || 0;

                    if (scoreA === 0 && scoreB === 0) {
                        alert('Please enter scores');
                        return;
                    }

                    // Create match record
                    const matchRecord = {
                        id: this.generateMatchId(),
                        tournamentId: match.tournamentId,
                        date: match.date,
                        format: match.format,
                        teamA: match.teamA,
                        teamB: match.teamB,
                        scoreA: scoreA,
                        scoreB: scoreB,
                        winner: scoreA > scoreB ? 'A' : 'B',
                        processed: false,
                        notes: match.notes || ''
                    };

                    this.matches.push(matchRecord);
                    this.processMatch(matchRecord);

                    // Mark as saved
                    if (!this.roundScores[match.id]) {
                        this.roundScores[match.id] = {};
                    }
                    if (!this.roundScores[match.id][1]) {
                        this.roundScores[match.id][1] = { A: scoreA, B: scoreB, saved: false };
                    }
                    this.roundScores[match.id][1].saved = true;

                    this.saveData();
                    alert('Match saved successfully!');
                },
                getTotalScore(scheduleId, team) {
                    if (!this.roundScores[scheduleId]) return 0;

                    let total = 0;
                    Object.keys(this.roundScores[scheduleId]).forEach(round => {
                        const roundData = this.roundScores[scheduleId][round];
                        if (roundData.saved && roundData[team] !== '') {
                            total += parseInt(roundData[team]) || 0;
                        }
                    });
                    return total;
                },
                allRoundsSaved(scheduleId, totalRounds) {
                    if (!this.roundScores[scheduleId]) return false;

                    for (let i = 1; i <= totalRounds; i++) {
                        if (!this.isRoundSaved(scheduleId, i)) {
                            return false;
                        }
                    }
                    return true;
                },
                finalizeMatch(schedule) {
                    const scoreA = this.getTotalScore(schedule.id, 'A');
                    const scoreB = this.getTotalScore(schedule.id, 'B');

                    // Create match with rounds data
                    const match = {
                        id: this.generateMatchId(),
                        date: schedule.date,
                        format: schedule.format,
                        teamA: [...schedule.teamA],
                        teamB: [...schedule.teamB],
                        scoreA: scoreA,
                        scoreB: scoreB,
                        winner: scoreA > scoreB ? 'A' : 'B',
                        rounds: JSON.parse(JSON.stringify(this.roundScores[schedule.id])), // Store round details
                        processed: false,
                        notes: schedule.notes || ''
                    };

                    this.matches.push(match);

                    // Auto-process
                    this.processMatch(match);

                    // Clean up
                    delete this.roundScores[schedule.id];
                    delete this.expandedSchedules[schedule.id];

                    this.saveData();
                    alert('Match recorded successfully!');
                },

                // Tournament Leaderboard Methods
                createTournamentSnapshot(tournamentId, date, notes) {
                    // Capture current player stats before tournament starts
                    const snapshot = {
                        tournamentId: tournamentId,
                        date: date,
                        notes: notes || '',
                        startTime: new Date().toISOString(),
                        endTime: null,
                        status: 'active', // 'active' or 'completed'
                        playerStatsBefore: this.players.map(p => ({
                            id: p.id,
                            name: p.name,
                            rating: p.rating,
                            wins: p.wins,
                            losses: p.losses
                        })),
                        playerStatsAfter: null,
                        tournamentStandings: null
                    };

                    this.tournamentLeaderboards.push(snapshot);
                },

                getTournamentStats(tournamentId) {
                    // Calculate stats for a specific tournament
                    const tournamentMatches = this.matches.filter(m => m.tournamentId === tournamentId);
                    const playerStats = {};

                    // Initialize stats for all players in tournament
                    tournamentMatches.forEach(match => {
                        [...match.teamA, ...match.teamB].forEach(playerId => {
                            if (!playerStats[playerId]) {
                                const player = this.players.find(p => p.id === playerId);
                                if (player) {
                                    playerStats[playerId] = {
                                        id: playerId,
                                        name: player.name,
                                        gamesPlayed: 0,
                                        wins: 0,
                                        losses: 0,
                                        pointsScored: 0,
                                        pointsConceded: 0
                                    };
                                }
                            }
                        });
                    });

                    // Calculate stats from matches
                    tournamentMatches.forEach(match => {
                        match.teamA.forEach(playerId => {
                            if (playerStats[playerId]) {
                                playerStats[playerId].gamesPlayed++;
                                playerStats[playerId].pointsScored += match.scoreA || 0;
                                playerStats[playerId].pointsConceded += match.scoreB || 0;
                                if (match.winner === 'A') {
                                    playerStats[playerId].wins++;
                                } else {
                                    playerStats[playerId].losses++;
                                }
                            }
                        });

                        match.teamB.forEach(playerId => {
                            if (playerStats[playerId]) {
                                playerStats[playerId].gamesPlayed++;
                                playerStats[playerId].pointsScored += match.scoreB || 0;
                                playerStats[playerId].pointsConceded += match.scoreA || 0;
                                if (match.winner === 'B') {
                                    playerStats[playerId].wins++;
                                } else {
                                    playerStats[playerId].losses++;
                                }
                            }
                        });
                    });

                    return Object.values(playerStats).sort((a, b) => {
                        // Sort by wins first, then by point differential
                        if (b.wins !== a.wins) return b.wins - a.wins;
                        const diffA = a.pointsScored - a.pointsConceded;
                        const diffB = b.pointsScored - b.pointsConceded;
                        return diffB - diffA;
                    });
                },

                finalizeTournamentSnapshot(tournamentId) {
                    const snapshot = this.tournamentLeaderboards.find(t => t.tournamentId === tournamentId);
                    if (!snapshot) return;

                    // Capture current player stats after tournament
                    snapshot.playerStatsAfter = this.players.map(p => ({
                        id: p.id,
                        name: p.name,
                        rating: p.rating,
                        wins: p.wins,
                        losses: p.losses
                    }));

                    // Calculate and save tournament-specific standings
                    snapshot.tournamentStandings = this.getTournamentStats(tournamentId);
                    snapshot.endTime = new Date().toISOString();
                    snapshot.status = 'completed';
                },

                getTournamentLeaderboard(tournamentId) {
                    return this.tournamentLeaderboards.find(t => t.tournamentId === tournamentId);
                },

                getLiveTournamentStandings(tournamentId) {
                    const leaderboard = this.getTournamentLeaderboard(tournamentId);
                    if (!leaderboard) return [];

                    let standings = [];
                    // If completed, return the finalized standings
                    if (leaderboard.status === 'completed' && leaderboard.tournamentStandings) {
                        standings = [...leaderboard.tournamentStandings];
                    } else {
                        // If active, calculate live standings from matches
                        standings = this.getTournamentStats(tournamentId);
                    }

                    // Apply sorting
                    return this.sortStandings(standings);
                },

                sortStandings(standings) {
                    const sorted = [...standings].sort((a, b) => {
                        let valA, valB;

                        switch(this.sortColumn) {
                            case 'name':
                                valA = a.name.toLowerCase();
                                valB = b.name.toLowerCase();
                                break;
                            case 'games':
                                valA = a.gamesPlayed;
                                valB = b.gamesPlayed;
                                break;
                            case 'wins':
                                valA = a.wins;
                                valB = b.wins;
                                break;
                            case 'losses':
                                valA = a.losses;
                                valB = b.losses;
                                break;
                            case 'pointsFor':
                                valA = a.pointsScored;
                                valB = b.pointsScored;
                                break;
                            case 'pointsAgainst':
                                valA = a.pointsConceded;
                                valB = b.pointsConceded;
                                break;
                            case 'pointDiff':
                            default:
                                valA = (a.pointsScored - a.pointsConceded);
                                valB = (b.pointsScored - b.pointsConceded);
                                break;
                        }

                        if (this.sortDirection === 'asc') {
                            return valA > valB ? 1 : valA < valB ? -1 : 0;
                        } else {
                            return valA < valB ? 1 : valA > valB ? -1 : 0;
                        }
                    });
                    return sorted;
                },

                sortBy(column) {
                    if (this.sortColumn === column) {
                        // Toggle direction if clicking same column
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // New column, default to descending for numbers, ascending for name
                        this.sortColumn = column;
                        this.sortDirection = column === 'name' ? 'asc' : 'desc';
                    }
                },

                sortLeagueBy(column) {
                    if (this.leagueSortColumn === column) {
                        // Toggle direction if clicking same column
                        this.leagueSortDirection = this.leagueSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // New column, default to descending for numbers, ascending for name
                        this.leagueSortColumn = column;
                        this.leagueSortDirection = column === 'name' ? 'asc' : 'desc';
                    }
                },

                // Tournament Editing
                openTournamentEditor(tournamentId) {
                    console.log('openTournamentEditor called with:', tournamentId);
                    console.log('Schedules for this tournament:', this.schedules.filter(s => s.tournamentId === tournamentId));
                    this.editingTournamentId = tournamentId;
                    this.showEditScheduleModal = true;
                    console.log('showEditScheduleModal set to:', this.showEditScheduleModal);
                },

                closeEditModal() {
                    this.showEditScheduleModal = false;
                    this.editingTournamentId = null;
                },

                getTournamentSchedules(tournamentId) {
                    return this.schedules.filter(s => s.tournamentId === tournamentId);
                },

                async deleteSchedule(scheduleId) {
                    if (!confirm('Are you sure you want to remove this match from the tournament?')) {
                        return;
                    }

                    // Delete from database first
                    try {
                        const { error } = await sb.from('schedules').delete().eq('id', scheduleId);
                        if (error) {
                            console.error('Error deleting schedule from database:', error);
                            alert('Error deleting schedule from database');
                            return;
                        }
                    } catch (error) {
                        console.error('Error deleting schedule:', error);
                        alert('Error deleting schedule');
                        return;
                    }

                    // Then remove from local array
                    const index = this.schedules.findIndex(s => s.id === scheduleId);
                    if (index > -1) {
                        this.schedules.splice(index, 1);
                    }
                },

                async saveTournamentChanges() {
                    try {
                        // Validate all schedules
                        const tournamentSchedules = this.getTournamentSchedules(this.editingTournamentId);

                        for (const schedule of tournamentSchedules) {
                            // Check for empty players
                            const allPlayers = [...schedule.teamA, ...schedule.teamB];
                            if (allPlayers.some(p => !p || p === '')) {
                                alert('Please fill in all player slots or remove incomplete matches');
                                return;
                            }

                            // Check for duplicate players in same match
                            const uniquePlayers = new Set(allPlayers);
                            if (uniquePlayers.size !== allPlayers.length) {
                                alert('A player cannot be on both teams in the same match');
                                return;
                            }
                        }

                        // Save to Supabase
                        await this.saveData();

                        alert('Tournament changes saved successfully!');
                        this.closeEditModal();
                    } catch (error) {
                        console.error('Error saving tournament changes:', error);
                        alert('Failed to save changes: ' + error.message);
                    }
                },

                // CSV Export/Import Methods
                downloadCSVTemplate() {
                    const csvContent = `Round,Court,Format,Team A Player 1,Team A Player 2,Team B Player 1,Team B Player 2,Games,Score A,Score B,Notes
1,1,doubles,John Smith,Jane Doe,Bob Wilson,Alice Brown,3,,,Opening round
1,2,doubles,Mike Johnson,Sarah Lee,Tom Davis,Emma White,3,,,
2,1,doubles,John Smith,Bob Wilson,Jane Doe,Alice Brown,3,,,Partner switch
2,2,doubles,Mike Johnson,Emma White,Sarah Lee,Tom Davis,3,,,
3,1,doubles,John Smith,Tom Davis,Jane Doe,Mike Johnson,3,,,Final round
3,2,doubles,Bob Wilson,Sarah Lee,Alice Brown,Emma White,3,,,`;

                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', 'tournament_template.csv');
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                downloadTournamentCSV(tournamentId) {
                    const tournamentSchedules = this.schedules.filter(s => s.tournamentId === tournamentId);

                    if (tournamentSchedules.length === 0) {
                        alert('No schedules found for this tournament');
                        return;
                    }

                    // Sort by round number and court
                    tournamentSchedules.sort((a, b) => {
                        if (a.roundNumber !== b.roundNumber) return a.roundNumber - b.roundNumber;
                        return a.court - b.court;
                    });

                    // Create CSV header with score columns
                    const csvRows = ['Round,Court,Format,Team A Player 1,Team A Player 2,Team B Player 1,Team B Player 2,Games,Score A,Score B,Notes'];

                    // Add data rows
                    tournamentSchedules.forEach(schedule => {
                        const teamANames = schedule.teamA.map(id => {
                            const player = this.players.find(p => p.id === id);
                            return player ? player.name : id;
                        });
                        const teamBNames = schedule.teamB.map(id => {
                            const player = this.players.find(p => p.id === id);
                            return player ? player.name : id;
                        });

                        // Find matching match to get scores if they exist
                        const matchingMatch = this.matches.find(m =>
                            m.date === schedule.date &&
                            m.tournamentId === schedule.tournamentId &&
                            JSON.stringify([...m.teamA].sort()) === JSON.stringify([...schedule.teamA].sort()) &&
                            JSON.stringify([...m.teamB].sort()) === JSON.stringify([...schedule.teamB].sort())
                        );

                        const scoreA = matchingMatch ? matchingMatch.scoreA : '';
                        const scoreB = matchingMatch ? matchingMatch.scoreB : '';

                        // Escape fields that might contain commas
                        const escapeField = (field) => {
                            if (field && (field.includes(',') || field.includes('"'))) {
                                return '"' + field.replace(/"/g, '""') + '"';
                            }
                            return field || '';
                        };

                        const row = [
                            schedule.roundNumber || 1,
                            schedule.court || 1,
                            schedule.format || 'doubles',
                            escapeField(teamANames[0] || ''),
                            escapeField(teamANames[1] || ''),
                            escapeField(teamBNames[0] || ''),
                            escapeField(teamBNames[1] || ''),
                            schedule.rounds || 3,
                            scoreA,
                            scoreB,
                            escapeField(schedule.notes || '')
                        ];
                        csvRows.push(row.join(','));
                    });

                    // Create and download file
                    const csvContent = csvRows.join('\n');
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);

                    // Get tournament date for filename
                    const tournamentDate = tournamentSchedules[0]?.date || new Date().toISOString().split('T')[0];
                    link.setAttribute('href', url);
                    link.setAttribute('download', `tournament_${tournamentId}_${tournamentDate}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                async uploadTournamentCSV(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const csvText = e.target.result;
                            const lines = csvText.split('\n').filter(line => line.trim());

                            if (lines.length < 2) {
                                alert('CSV file is empty or has no data rows');
                                return;
                            }

                            // Parse header
                            const header = lines[0].split(',').map(h => h.trim().toLowerCase());

                            // Validate header
                            if (header.length < 7) {
                                alert('Invalid CSV format. Please use the template.');
                                return;
                            }

                            // Ask for tournament date
                            const tournamentDate = prompt('Enter tournament date (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
                            if (!tournamentDate || !/^\d{4}-\d{2}-\d{2}$/.test(tournamentDate)) {
                                alert('Invalid date format. Please use YYYY-MM-DD');
                                return;
                            }

                            // Generate tournament ID
                            const tournamentId = 'T' + Date.now();

                            // Find max schedule ID
                            const existingScheduleIds = this.schedules.map(s => {
                                const match = s.id.match(/^S(\d+)$/);
                                return match ? parseInt(match[1]) : 0;
                            });
                            let scheduleIdCounter = existingScheduleIds.length > 0 ? Math.max(...existingScheduleIds) + 1 : 1;

                            // Find max match ID
                            const existingMatchIds = this.matches.map(m => {
                                const match = m.id.match(/^M(\d+)$/);
                                return match ? parseInt(match[1]) : 0;
                            });
                            let matchIdCounter = existingMatchIds.length > 0 ? Math.max(...existingMatchIds) + 1 : 1;

                            const newSchedules = [];
                            const newMatches = [];
                            const unknownPlayers = [];

                            // Parse CSV helper function for quoted fields
                            const parseCSVLine = (line) => {
                                const result = [];
                                let current = '';
                                let inQuotes = false;

                                for (let i = 0; i < line.length; i++) {
                                    const char = line[i];
                                    if (char === '"') {
                                        if (inQuotes && line[i + 1] === '"') {
                                            current += '"';
                                            i++;
                                        } else {
                                            inQuotes = !inQuotes;
                                        }
                                    } else if (char === ',' && !inQuotes) {
                                        result.push(current.trim());
                                        current = '';
                                    } else {
                                        current += char;
                                    }
                                }
                                result.push(current.trim());
                                return result;
                            };

                            // Parse data rows
                            for (let i = 1; i < lines.length; i++) {
                                const values = parseCSVLine(lines[i]);
                                if (values.length < 7 || !values[0]) continue;

                                const roundNumber = parseInt(values[0]) || 1;
                                const court = parseInt(values[1]) || 1;
                                const format = (values[2] || 'doubles').toLowerCase();
                                const teamAPlayer1 = values[3]?.trim();
                                const teamAPlayer2 = values[4]?.trim();
                                const teamBPlayer1 = values[5]?.trim();
                                const teamBPlayer2 = values[6]?.trim();
                                const games = parseInt(values[7]) || 3;
                                const scoreA = values[8]?.trim() ? parseInt(values[8]) : null;
                                const scoreB = values[9]?.trim() ? parseInt(values[9]) : null;
                                const notes = values[10]?.trim() || '';

                                // Find player IDs by name (case-insensitive)
                                const findPlayerId = (name) => {
                                    if (!name) return null;
                                    const player = this.players.find(p =>
                                        p.name.toLowerCase() === name.toLowerCase()
                                    );
                                    if (!player && name) {
                                        if (!unknownPlayers.includes(name)) {
                                            unknownPlayers.push(name);
                                        }
                                        return null;
                                    }
                                    return player ? player.id : null;
                                };

                                // Build teams based on format
                                let teamA = [];
                                let teamB = [];

                                if (format === 'singles') {
                                    const a1 = findPlayerId(teamAPlayer1);
                                    const b1 = findPlayerId(teamBPlayer1);
                                    if (a1) teamA = [a1];
                                    if (b1) teamB = [b1];
                                } else if (format === 'doubles') {
                                    const a1 = findPlayerId(teamAPlayer1);
                                    const a2 = findPlayerId(teamAPlayer2);
                                    const b1 = findPlayerId(teamBPlayer1);
                                    const b2 = findPlayerId(teamBPlayer2);
                                    if (a1) teamA.push(a1);
                                    if (a2) teamA.push(a2);
                                    if (b1) teamB.push(b1);
                                    if (b2) teamB.push(b2);
                                } else if (format === '2v1') {
                                    const a1 = findPlayerId(teamAPlayer1);
                                    const a2 = findPlayerId(teamAPlayer2);
                                    const b1 = findPlayerId(teamBPlayer1);
                                    if (a1) teamA.push(a1);
                                    if (a2) teamA.push(a2);
                                    if (b1) teamB.push(b1);
                                }

                                // Only add if we have valid teams
                                if (teamA.length > 0 && teamB.length > 0) {
                                    const scheduleId = 'S' + String(scheduleIdCounter++).padStart(4, '0');

                                    newSchedules.push({
                                        id: scheduleId,
                                        tournamentId: tournamentId,
                                        date: tournamentDate,
                                        court: court,
                                        format: format,
                                        teamA: teamA,
                                        teamB: teamB,
                                        rounds: games,
                                        roundNumber: roundNumber,
                                        notes: notes
                                    });

                                    // If scores are provided, create a match record
                                    if (scoreA !== null && scoreB !== null && !isNaN(scoreA) && !isNaN(scoreB)) {
                                        newMatches.push({
                                            id: 'M' + String(matchIdCounter++).padStart(4, '0'),
                                            tournamentId: tournamentId,
                                            date: tournamentDate,
                                            format: format,
                                            teamA: teamA,
                                            teamB: teamB,
                                            scoreA: scoreA,
                                            scoreB: scoreB,
                                            notes: notes,
                                            processed: false
                                        });
                                    }
                                }
                            }

                            if (unknownPlayers.length > 0) {
                                const proceed = confirm(
                                    `The following players were not found and their matches will be skipped:\n\n${unknownPlayers.join('\n')}\n\nDo you want to continue with the other matches?`
                                );
                                if (!proceed) {
                                    event.target.value = '';
                                    return;
                                }
                            }

                            if (newSchedules.length === 0) {
                                alert('No valid matches found in the CSV file. Please check player names match exactly.');
                                event.target.value = '';
                                return;
                            }

                            // Add schedules
                            this.schedules.push(...newSchedules);

                            // Add matches and process them for ratings
                            if (newMatches.length > 0) {
                                for (const match of newMatches) {
                                    this.matches.push(match);
                                    this.processMatch(match);
                                }
                            }

                            // Create tournament snapshot
                            this.createTournamentSnapshot(tournamentId, tournamentDate, '');

                            // Save to database
                            await this.saveData();

                            let message = `Successfully imported ${newSchedules.length} matches for tournament ${tournamentId}!`;
                            if (newMatches.length > 0) {
                                message += `\n\n${newMatches.length} matches with scores were also recorded to match history and ratings updated.`;
                            }
                            alert(message);
                            event.target.value = '';
                        } catch (error) {
                            console.error('Error parsing CSV:', error);
                            alert('Error parsing CSV file: ' + error.message);
                            event.target.value = '';
                        }
                    };

                    reader.readAsText(file);
                },

                // Data Management
                deleteTodaysMatches() {
                    const today = new Date().toISOString().split('T')[0];
                    const todaysMatches = this.matches.filter(m => m.date === today);

                    if (todaysMatches.length === 0) {
                        alert('No matches recorded today');
                        return;
                    }

                    if (!confirm(`Delete ${todaysMatches.length} matches recorded today? This will also revert rating changes.`)) {
                        return;
                    }

                    // Get match IDs to delete
                    const matchIdsToDelete = todaysMatches.map(m => m.id);

                    // Remove rating history for these matches
                    this.ratingsHistory = this.ratingsHistory.filter(h => !matchIdsToDelete.includes(h.matchId));

                    // Recalculate player ratings from scratch
                    // Reset all players to base rating
                    this.players.forEach(player => {
                        player.rating = 200;
                        player.gamesPlayed = 0;
                        player.wins = 0;
                        player.losses = 0;
                    });

                    // Remove today's matches
                    this.matches = this.matches.filter(m => m.date !== today);

                    // Reprocess all remaining matches in chronological order
                    const processedMatches = this.matches.filter(m => m.processed).sort((a, b) => new Date(a.date) - new Date(b.date));

                    // Reset processed flag
                    this.matches.forEach(m => m.processed = false);

                    // Clear ratings history (will be rebuilt)
                    this.ratingsHistory = [];

                    // Reprocess each match
                    processedMatches.forEach(match => {
                        this.processMatch(match);
                    });

                    this.saveData();
                    alert(`Deleted ${todaysMatches.length} matches from today and recalculated all ratings!`);
                },
                recalculateAllRatings() {
                    if (!confirm('Recalculate all ratings starting from 200?\n\nThis will:\n- Reset all players to 200\n- Reprocess all match history\n- Keep all matches intact\n\nContinue?')) {
                        return;
                    }

                    // Reset all players to base rating of 200
                    this.players.forEach(player => {
                        player.rating = 200;
                        player.gamesPlayed = 0;
                        player.wins = 0;
                        player.losses = 0;
                    });

                    // Get all processed matches in chronological order
                    const processedMatches = this.matches.filter(m => m.processed).sort((a, b) => new Date(a.date) - new Date(b.date));

                    // Reset processed flag on all matches
                    this.matches.forEach(m => m.processed = false);

                    // Clear ratings history (will be rebuilt)
                    this.ratingsHistory = [];

                    // Reprocess each match in order
                    processedMatches.forEach(match => {
                        this.processMatch(match);
                    });

                    this.saveData();
                    alert(`Successfully recalculated all ratings from 200! Processed ${processedMatches.length} matches.`);
                },
                async fixNegativeRatings() {
                    // Find players with negative ratings
                    const negativeRatings = this.players.filter(p => p.rating < 0);

                    if (negativeRatings.length === 0) {
                        alert('No negative ratings found! All ratings are already 0 or above.');
                        return;
                    }

                    if (!confirm(`Found ${negativeRatings.length} player(s) with negative ratings:\n\n${negativeRatings.map(p => `${p.name}: ${Math.round(p.rating)}`).join('\n')}\n\nSet all to 0?`)) {
                        return;
                    }

                    // Fix the ratings
                    negativeRatings.forEach(player => {
                        player.rating = 0;
                    });

                    await this.saveData();
                    alert(`Fixed ${negativeRatings.length} negative rating(s). All ratings are now 0 or above.`);
                },
                async saveData() {
                    try {
                        console.log('Starting saveData...');
                        console.log(`Saving: ${this.players.length} players, ${this.matches.length} matches, ${this.ratingsHistory.length} ratings, ${this.schedules.length} schedules`);

                        // Save players
                        if (this.players.length > 0) {
                            console.log('Saving players...');
                            const playersResult = await sb.from('players').upsert(this.players);
                            if (playersResult.error) {
                                console.error('Players save error:', playersResult.error);
                                throw new Error('Players: ' + playersResult.error.message);
                            }
                        }

                        // Save matches
                        if (this.matches.length > 0) {
                            console.log('Saving matches...');
                            // Remove scheduleId field as it's not in the database schema
                            const matchesToSave = this.matches.map(m => {
                                const { scheduleId, ...matchWithoutScheduleId } = m;
                                return matchWithoutScheduleId;
                            });
                            const matchesResult = await sb.from('matches').upsert(matchesToSave);
                            if (matchesResult.error) {
                                console.error('Matches save error:', matchesResult.error);
                                throw new Error('Matches: ' + matchesResult.error.message);
                            }
                        }

                        // Save ratings history
                        if (this.ratingsHistory.length > 0) {
                            console.log('Saving ratings history...');
                            // Remove duplicates based on id before upserting
                            const uniqueRatings = [];
                            const seenIds = new Set();
                            this.ratingsHistory.forEach(rating => {
                                if (!seenIds.has(rating.id)) {
                                    seenIds.add(rating.id);
                                    uniqueRatings.push(rating);
                                }
                            });
                            console.log(`Ratings: ${this.ratingsHistory.length} total, ${uniqueRatings.length} unique`);

                            const ratingsResult = await sb.from('ratings_history').upsert(uniqueRatings);
                            if (ratingsResult.error) {
                                console.error('Ratings save error:', ratingsResult.error);
                                throw new Error('Ratings: ' + ratingsResult.error.message);
                            }
                        }

                        // Save schedules
                        if (this.schedules.length > 0) {
                            console.log('Saving schedules...');
                            // Remove duplicates based on id before upserting
                            const uniqueSchedules = [];
                            const seenIds = new Set();
                            this.schedules.forEach(schedule => {
                                if (!seenIds.has(schedule.id)) {
                                    seenIds.add(schedule.id);
                                    uniqueSchedules.push(schedule);
                                }
                            });
                            console.log(`Schedules: ${this.schedules.length} total, ${uniqueSchedules.length} unique`);

                            const schedulesResult = await sb.from('schedules').upsert(uniqueSchedules).select();
                            console.log('Schedules upsert result:', schedulesResult);
                            if (schedulesResult.error) {
                                console.error('Schedules save error:', schedulesResult.error);
                                console.error('First schedule object:', uniqueSchedules[0]);
                                throw new Error('Schedules: ' + schedulesResult.error.message);
                            }
                            console.log(`Schedules saved: ${schedulesResult.data?.length || 0} rows returned`);
                        }

                        // Save tournament leaderboards
                        if (this.tournamentLeaderboards.length > 0) {
                            console.log('Saving tournament leaderboards...');
                            const leaderboardsResult = await sb.from('tournament_leaderboards').upsert(this.tournamentLeaderboards);
                            if (leaderboardsResult.error) {
                                console.error('Tournament leaderboards save error:', leaderboardsResult.error);
                                throw new Error('Tournament Leaderboards: ' + leaderboardsResult.error.message);
                            }
                        }

                        console.log('Data saved to Supabase successfully');
                    } catch (error) {
                        console.error('Error saving to Supabase:', error);
                        alert('Failed to save data to database: ' + error.message);
                        throw error;
                    }
                },
                async loadData() {
                    try {
                        // Helper function to fetch all rows with pagination (bypasses 1000 row server limit)
                        const fetchAll = async (table) => {
                            let allData = [];
                            let from = 0;
                            const batchSize = 1000;
                            while (true) {
                                const { data, error } = await sb.from(table).select('*').range(from, from + batchSize - 1);
                                if (error) throw error;
                                if (!data || data.length === 0) break;
                                allData = allData.concat(data);
                                if (data.length < batchSize) break;
                                from += batchSize;
                            }
                            return allData;
                        };

                        // Load from Supabase with pagination
                        const [players, matches, ratingsHistory, schedules, leaderboards, gameSessions, playerAvailability] = await Promise.all([
                            fetchAll('players'),
                            fetchAll('matches'),
                            fetchAll('ratings_history'),
                            fetchAll('schedules'),
                            fetchAll('tournament_leaderboards'),
                            fetchAll('game_sessions'),
                            fetchAll('player_availability')
                        ]);

                        this.players = (players || []).map(p => ({
                            ...p,
                            rating: Math.max(0, p.rating || 0)
                        }));
                        this.matches = matches || [];
                        this.ratingsHistory = ratingsHistory || [];
                        this.schedules = schedules || [];
                        this.tournamentLeaderboards = leaderboards || [];
                        this.gameSessions = gameSessions || [];
                        this.playerAvailability = playerAvailability || [];

                        console.log('Data loaded from Supabase successfully');
                        console.log(`Loaded: ${this.players.length} players, ${this.matches.length} matches, ${this.schedules.length} schedules, ${this.tournamentLeaderboards.length} tournaments, ${this.gameSessions.length} game sessions, ${this.playerAvailability.length} availability records`);
                    } catch (error) {
                        console.error('Error loading from Supabase:', error);
                        alert('Failed to load data from database. Please check your connection and refresh the page.');
                    }

                    // Check admin status
                    if (localStorage.getItem('isAdmin') === 'true') {
                        this.isAdmin = true;
                    }
                },
                async migrateTournamentData() {
                    // Find all unique tournament IDs from schedules
                    const tournamentIds = [...new Set(
                        this.schedules
                            .filter(s => s.tournamentId && s.tournamentId.trim())
                            .map(s => s.tournamentId)
                    )];

                    if (tournamentIds.length === 0) {
                        this.migrationStatus = {
                            success: false,
                            message: 'No tournament data found to migrate'
                        };
                        setTimeout(() => { this.migrationStatus = null; }, 3000);
                        return;
                    }

                    try {
                        console.log(`Found ${tournamentIds.length} tournaments to migrate...`);
                        
                        const leaderboardsToMigrate = [];
                        
                        // Generate leaderboard for each tournament
                        for (const tournamentId of tournamentIds) {
                            // Get tournament info from first schedule with this ID
                            const tournamentSchedule = this.schedules.find(s => s.tournamentId === tournamentId);
                            const tournamentDate = tournamentSchedule ? tournamentSchedule.date : '';
                            
                            // Check if already completed
                            const existingLeaderboard = this.tournamentLeaderboards.find(t => t.tournamentId === tournamentId);
                            if (existingLeaderboard) {
                                leaderboardsToMigrate.push(existingLeaderboard);
                                continue;
                            }
                            
                            // Calculate tournament standings
                            const standings = this.getTournamentStats(tournamentId);
                            
                            // Create leaderboard record
                            const leaderboardRecord = {
                                tournamentId: tournamentId,
                                date: tournamentDate,
                                tournamentStandings: standings,
                                status: 'completed', // Assume past tournaments are completed
                                startTime: tournamentDate, // Use tournament date as start time
                                endTime: new Date().toISOString(),
                                playerStatsBefore: [], // Empty array for past tournaments
                                playerStatsAfter: [] // Empty array for past tournaments
                            };
                            
                            leaderboardsToMigrate.push(leaderboardRecord);
                        }
                        
                        console.log(`Migrating ${leaderboardsToMigrate.length} tournament records...`);
                        
                        // Save tournament leaderboards to Supabase
                        const leaderboardsResult = await sb.from('tournament_leaderboards').upsert(leaderboardsToMigrate);
                        
                        if (leaderboardsResult.error) {
                            console.error('Tournament migration error:', leaderboardsResult.error);
                            this.migrationStatus = {
                                success: false,
                                message: `Migration failed: ${leaderboardsResult.error.message}`
                            };
                        } else {
                            console.log('Tournament data migrated successfully');
                            // Update local array
                            this.tournamentLeaderboards = [...this.tournamentLeaderboards, ...leaderboardsToMigrate];
                            this.migrationStatus = {
                                success: true,
                                message: `Successfully migrated ${leaderboardsToMigrate.length} tournament records`
                            };
                        }
                    } catch (error) {
                        console.error('Migration error:', error);
                        this.migrationStatus = {
                            success: false,
                            message: `Migration failed: ${error.message}`
                        };
                    }

                    // Clear status after 5 seconds
                    setTimeout(() => { this.migrationStatus = null; }, 5000);
                },
                exportJSON() {
                    const data = {
                        players: this.players,
                        matches: this.matches,
                        ratingsHistory: this.ratingsHistory,
                        tournamentLeaderboards: this.tournamentLeaderboards,
                        schedules: this.schedules,
                        exportDate: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pickleball-backup-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                },
                exportCSV() {
                    let csv = 'ID,Name,Rating,Games Played,Wins,Losses,Draws,Win %\n';
                    this.sortedPlayers.forEach(player => {
                        const winPct = player.gamesPlayed > 0 ? Math.round((player.wins + player.draws * 0.5) / player.gamesPlayed * 100) : 0;
                        csv += `${player.id},${player.name},${Math.round(player.rating)},${player.gamesPlayed},${player.wins},${player.losses},${player.draws || 0},${winPct}\n`;
                    });
                    
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pickleball-players-${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                },
                handleFileImport(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (confirm('This will replace all current data. Are you sure?')) {
                                this.players = (data.players || []).map(p => ({
                                    ...p,
                                    rating: Math.max(0, p.rating || 0)
                                }));
                                this.matches = data.matches || [];
                                this.ratingsHistory = data.ratingsHistory || [];
                                this.schedules = data.schedules || [];
                                this.tournamentLeaderboards = data.tournamentLeaderboards || [];
                                this.saveData();
                                alert('Data imported successfully!');
                            }
                        } catch (error) {
                            alert('Error importing file. Please ensure it\'s a valid JSON backup.');
                        }
                    };
                    reader.readAsText(file);
                },
                clearAllData() {
                    if (confirm('This will delete ALL data. This cannot be undone. Are you sure?')) {
                        if (confirm('Are you really sure? All players, matches, and schedules will be lost!')) {
                            this.players = [];
                            this.matches = [];
                            this.ratingsHistory = [];
                            this.schedules = [];
                            this.tournamentLeaderboards = [];
                            this.saveData();
                            alert('All data has been cleared.');
                        }
                    }
                },
                printLeague() {
                    window.print();
                },

                // Signup Sheet Methods
                async addGameSession() {
                    try {
                        const sessionId = 'GS' + String(this.gameSessions.length + 1).padStart(3, '0');
                        const sessionData = {
                            id: sessionId,
                            date: this.newGameSession.date,
                            time: this.newGameSession.time,
                            courts: this.newGameSession.courts,
                            maxPlayers: this.newGameSession.maxPlayers,
                            notes: this.newGameSession.notes,
                            status: this.newGameSession.status,
                            createdBy: 'admin',
                            createdAt: new Date().toISOString()
                        };

                        const { data, error } = await sb.from('game_sessions').upsert(sessionData);
                        if (error) throw error;

                        this.gameSessions.push(sessionData);
                        this.showAddSession = false;
                        
                        // Reset form
                        this.newGameSession = {
                            date: new Date().toISOString().split('T')[0],
                            time: '18:00',
                            courts: 2,
                            maxPlayers: 8,
                            notes: '',
                            status: 'active'
                        };

                        alert('Game session added successfully!');
                    } catch (error) {
                        console.error('Error adding game session:', error);
                        alert('Error adding game session: ' + error.message);
                    }
                },

                async setPlayerAvailability(sessionId, available) {
                    if (!this.selectedPlayerId) {
                        alert('Please select your name first!');
                        return;
                    }

                    try {
                        // Check if availability already exists
                        const existingIndex = this.playerAvailability.findIndex(
                            pa => pa.gameSessionId === sessionId && pa.playerId === this.selectedPlayerId
                        );

                        const availabilityId = existingIndex >= 0 ? 
                            this.playerAvailability[existingIndex].id : 
                            'PA' + String(this.playerAvailability.length + 1).padStart(3, '0');

                        const availabilityData = {
                            id: availabilityId,
                            gameSessionId: sessionId,
                            playerId: this.selectedPlayerId,
                            available: available,
                            notes: '',
                            signupAt: new Date().toISOString()
                        };

                        const { data, error } = await sb.from('player_availability').upsert(availabilityData);
                        if (error) throw error;

                        if (existingIndex >= 0) {
                            this.playerAvailability[existingIndex] = availabilityData;
                        } else {
                            this.playerAvailability.push(availabilityData);
                        }

                        const statusText = available ? 'available' : 'not available';
                        alert(`Marked as ${statusText} for this session!`);
                    } catch (error) {
                        console.error('Error setting availability:', error);
                        alert('Error setting availability: ' + error.message);
                    }
                },

                getPlayerAvailability(sessionId) {
                    if (!this.selectedPlayerId) return null;
                    const availability = this.playerAvailability.find(
                        pa => pa.gameSessionId === sessionId && pa.playerId === this.selectedPlayerId
                    );
                    return availability ? availability.available : null;
                },

                getAvailablePlayersCount(sessionId) {
                    return this.playerAvailability.filter(
                        pa => pa.gameSessionId === sessionId && pa.available === true
                    ).length;
                },

                getUnavailablePlayersCount(sessionId) {
                    return this.playerAvailability.filter(
                        pa => pa.gameSessionId === sessionId && pa.available === false
                    ).length;
                },

                getNoResponsePlayersCount(sessionId) {
                    const respondedPlayerIds = this.playerAvailability
                        .filter(pa => pa.gameSessionId === sessionId)
                        .map(pa => pa.playerId);
                    return this.players.length - respondedPlayerIds.length;
                },

                getSessionAvailablePlayers(sessionId) {
                    const availablePlayerIds = this.playerAvailability
                        .filter(pa => pa.gameSessionId === sessionId && pa.available === true)
                        .map(pa => pa.playerId);
                    return this.players.filter(p => availablePlayerIds.includes(p.id));
                },

                getSessionUnavailablePlayers(sessionId) {
                    const unavailablePlayerIds = this.playerAvailability
                        .filter(pa => pa.gameSessionId === sessionId && pa.available === false)
                        .map(pa => pa.playerId);
                    return this.players.filter(p => unavailablePlayerIds.includes(p.id));
                },

                getSessionNoResponsePlayers(sessionId) {
                    const respondedPlayerIds = this.playerAvailability
                        .filter(pa => pa.gameSessionId === sessionId)
                        .map(pa => pa.playerId);
                    return this.players.filter(p => !respondedPlayerIds.includes(p.id));
                },

                toggleSessionDetails(sessionId) {
                    this.sessionDetailsExpanded[sessionId] = !this.sessionDetailsExpanded[sessionId];
                },

                async cancelGameSession(sessionId) {
                    if (!confirm('Are you sure you want to delete this game session? This action cannot be undone.')) return;
                    
                    try {
                        // Delete from database
                        const { error } = await sb.from('game_sessions')
                            .delete()
                            .eq('id', sessionId);
                        
                        if (error) throw error;
                        
                        // Remove from local array
                        const sessionIndex = this.gameSessions.findIndex(s => s.id === sessionId);
                        if (sessionIndex >= 0) {
                            this.gameSessions.splice(sessionIndex, 1);
                        }
                        
                        // Remove any related availability records
                        this.playerAvailability = this.playerAvailability.filter(
                            pa => pa.gameSessionId !== sessionId
                        );
                        
                        alert('Game session deleted successfully!');
                    } catch (error) {
                        console.error('Error deleting session:', error);
                        alert('Error deleting session: ' + error.message);
                    }
                },


                async createTournamentFromSession(sessionId) {
                    const session = this.gameSessions.find(s => s.id === sessionId);
                    const availablePlayers = this.getSessionAvailablePlayers(sessionId);
                    
                    if (availablePlayers.length < 4) {
                        alert('Minimum 4 players required to create a tournament');
                        return;
                    }

                    if (!confirm(`Create tournament for ${session.date} with ${availablePlayers.length} available players?`)) {
                        return;
                    }

                    try {
                        // Use existing schedule generator logic
                        this.scheduleGenerator.date = session.date;
                        this.scheduleGenerator.courts = session.courts;
                        this.scheduleGenerator.availablePlayers = availablePlayers.map(p => p.id);
                        this.scheduleGenerator.notes = session.notes || `Tournament from ${session.date}`;
                        
                        await this.generateSchedule();
                        
                        // Switch to scheduler tab to show generated schedule
                        this.activeTab = 'scheduler';
                        alert('Tournament created! Check the scheduler tab to review and save the schedule.');
                    } catch (error) {
                        console.error('Error creating tournament:', error);
                        alert('Error creating tournament: ' + error.message);
                    }
                },

                formatDateDisplay(date) {
                    return new Date(date).toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                },

                // Utility Methods
                formatDate(date) {
                    return new Date(date).toLocaleDateString('en-US', { 
                        weekday: 'short', 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                },
                getPlayerName(playerId) {
                    const player = this.players.find(p => p.id === playerId);
                    return player ? player.name : 'Unknown';
                },
                getTeamNames(playerIds) {
                    return playerIds.map(id => this.getPlayerName(id)).join(' & ');
                },
                fillFromSchedule(schedule) {
                    this.newMatch.format = schedule.format || 'doubles';
                    this.newMatch.date = schedule.date;
                    this.newMatch.teamA = [...schedule.teamA];
                    this.newMatch.teamB = [...schedule.teamB];
                    this.newMatch.notes = `Court ${schedule.court} - ${schedule.notes || ''}`;
                    this.newMatch.scheduleId = schedule.id;
                    // Scroll to form
                    setTimeout(() => {
                        const formSection = document.querySelector('select[multiple]');
                        if (formSection) {
                            formSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100);
                }
            },
            mounted() {
                // Check for site authentication
                if (sessionStorage.getItem('siteAuthenticated') === 'true') {
                    this.siteAuthenticated = true;
                }
                this.loadData();
            }
        }).mount('#app');
    </script>

    <style>
        @media print {
            body * {
                visibility: hidden;
            }
            #app .bg-white.rounded-lg.shadow {
                visibility: visible;
                position: absolute;
                left: 0;
                top: 0;
            }
        }
    </style>
</body>
</html>
